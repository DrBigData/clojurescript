(ns bs)

(def nss
'{cljs.core {:defs {sorted-map {:arglists (quote ([& keyvals])), :method-params ([{:name keyvals, :tag nil, :shadow nil}]), :name cljs.core/sorted-map, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :line 5508, :fn-var true, :file nil}, re-pattern {:arglists (quote ([s])), :method-params ([{:name s, :tag nil, :shadow nil}]), :name cljs.core/re-pattern, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns an instance of RegExp which has compiled the provided string.", :line 6150, :fn-var true, :file nil}, keyword? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/keyword?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1017, :fn-var true, :file nil, :tag boolean}, val {:arglists (quote ([map-entry])), :method-params ([{:name map-entry, :tag nil, :shadow nil}]), :name cljs.core/val, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns the value in the map entry.", :line 5542, :fn-var true, :file nil}, chunked-seq? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/chunked-seq?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 948, :fn-var true, :file nil, :tag boolean}, equiv-sequential {:arglists (quote ([x y])), :method-params ([{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}]), :name cljs.core/equiv-sequential, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false.", :line 1502, :fn-var true, :file nil}, pop-tail {:arglists (quote ([pv level node])), :method-params ([{:name pv, :tag nil, :shadow nil} {:name level, :tag nil, :shadow nil} {:name node, :tag nil, :shadow nil}]), :name cljs.core/pop-tail, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 2905, :fn-var true, :file nil}, *main-cli-fn* {:line 72, :file nil, :doc "When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments", :name cljs.core/*main-cli-fn*}, object-array {:arglists (quote ([size-or-seq] [size init-val-or-seq])), :method-params ([{:name size-or-seq, :tag nil, :shadow nil}] [{:name size, :tag nil, :shadow nil} {:name init-val-or-seq, :tag nil, :shadow nil}]), :name cljs.core/object-array, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 2016, :fn-var true, :file nil}, pr-sequential-writer {:arglists (quote ([writer print-one begin sep end opts coll])), :method-params ([{:name writer, :tag nil, :shadow nil} {:name print-one, :tag nil, :shadow nil} {:name begin, :tag nil, :shadow nil} {:name sep, :tag nil, :shadow nil} {:name end, :tag nil, :shadow nil} {:name opts, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/pr-sequential-writer, :protocol-impl nil, :max-fixed-arity 7, :protocol-inline nil, :variadic false, :line 6167, :fn-var true, :file nil}, max-key {:arglists (quote ([k x] [k x y] [k x y & more])), :method-params ([{:name k, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil}] [{:name k, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name k, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/max-key, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic true, :doc "Returns the x for which (k x), a number, is greatest.", :line 5857, :fn-var true, :file nil}, hash-coll {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/hash-coll, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 1520, :fn-var true, :file nil}, list* {:arglists (quote ([args] [a args] [a b args] [a b c args] [a b c d & more])), :method-params ([{:name args, :tag nil, :shadow nil}] [{:name a, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}] [{:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}] [{:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}] [{:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/list*, :protocol-impl nil, :max-fixed-arity 4, :protocol-inline nil, :variadic true, :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :line 2078, :fn-var true, :file nil}, IEditableCollection {:line 276, :file nil, :protocol-symbol true, :name cljs.core/IEditableCollection}, -contains-key? {:arglists (quote ([coll k])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil}]), :protocol cljs.core/IAssociative, :name cljs.core/-contains-key?, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 182, :fn-var true, :file nil}, pr-seq-writer {:arglists (quote ([objs writer opts])), :method-params ([{:name objs, :tag nil, :shadow nil} {:name writer, :tag nil, :shadow nil} {:name opts, :tag nil, :shadow nil}]), :name cljs.core/pr-seq-writer, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 6249, :fn-var true, :file nil}, == {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/==, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :line 1399, :fn-var true, :file nil, :tag boolean}, chunk-buffer {:arglists (quote ([capacity])), :method-params ([{:name capacity, :tag nil, :shadow nil}]), :name cljs.core/chunk-buffer, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1846, :fn-var true, :file nil}, -entry-key {:arglists (quote ([coll entry])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name entry, :tag nil, :shadow nil}]), :protocol cljs.core/ISorted, :name cljs.core/-entry-key, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 244, :fn-var true, :file nil}, -next {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/INext, :name cljs.core/-next, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 176, :fn-var true, :file nil}, array-map-index-of {:arglists (quote ([m k])), :method-params ([{:name m, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil}]), :name cljs.core/array-map-index-of, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 3789, :fn-var true, :file nil}, TransientArrayMap {:protocols #{cljs.core/ICounted cljs.core/ITransientMap cljs.core/ITransientAssociative cljs.core/ITransientCollection cljs.core/ILookup}, :num-fields 3, :type true, :line 3935, :file nil, :declared true, :name cljs.core/TransientArrayMap}, IHash {:line 226, :file nil, :protocol-symbol true, :name cljs.core/IHash}, array->transient-hash-map {:arglists (quote ([len arr])), :method-params ([{:name len, :tag nil, :shadow nil} {:name arr, :tag nil, :shadow nil}]), :name cljs.core/array->transient-hash-map, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 4005, :fn-var true, :file nil}, instance? {:arglists (quote ([t o])), :method-params ([{:name t, :tag nil, :shadow nil} {:name o, :tag nil, :shadow nil}]), :name cljs.core/instance?, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 372, :fn-var true, :file nil, :tag boolean}, -flush {:arglists (quote ([writer])), :method-params ([{:name writer, :tag nil, :shadow nil}]), :protocol cljs.core/IWriter, :name cljs.core/-flush, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 256, :fn-var true, :file nil}, tv-editable-root {:arglists (quote ([node])), :method-params ([{:name node, :tag nil, :shadow nil}]), :name cljs.core/tv-editable-root, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 3248, :fn-var true, :file nil}, pr-str-with-opts {:arglists (quote ([objs opts])), :method-params ([{:name objs, :tag nil, :shadow nil} {:name opts, :tag nil, :shadow nil}]), :name cljs.core/pr-str-with-opts, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts", :line 6262, :fn-var true, :file nil}, prn-str-with-opts {:arglists (quote ([objs opts])), :method-params ([{:name objs, :tag nil, :shadow nil} {:name opts, :tag nil, :shadow nil}]), :name cljs.core/prn-str-with-opts, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Same as pr-str-with-opts followed by (newline)", :line 6270, :fn-var true, :file nil}, format {:arglists (quote ([fmt & args])), :method-params ([{:name fmt, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}]), :name cljs.core/format, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic true, :doc "Formats a string using goog.string.format.", :line 1473, :fn-var true, :file nil}, sequential? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/sequential?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if coll satisfies ISequential", :line 929, :fn-var true, :file nil, :tag boolean}, fn? {:arglists (quote ([f])), :method-params ([{:name f, :tag nil, :shadow nil}]), :name cljs.core/fn?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1028, :fn-var true, :file nil, :tag boolean}, empty {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/empty, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns an empty collection of the same category as coll, or nil", :line 754, :fn-var true, :file nil}, TransientVector {:protocols #{cljs.core/IFn cljs.core/IIndexed cljs.core/ICounted cljs.core/ITransientVector cljs.core/ITransientAssociative cljs.core/ITransientCollection cljs.core/ILookup}, :num-fields 4, :type true, :line 3300, :file nil, :declared true, :name cljs.core/TransientVector}, dorun {:arglists (quote ([coll] [n coll])), :method-params ([{:name coll, :tag nil, :shadow nil}] [{:name n, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/dorun, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :line 6088, :fn-var true, :file nil}, remove-method {:arglists (quote ([multifn dispatch-val])), :method-params ([{:name multifn, :tag nil, :shadow nil} {:name dispatch-val, :tag nil, :shadow nil}]), :name cljs.core/remove-method, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Removes the method of multimethod associated with dispatch-value.", :line 7166, :fn-var true, :file nil}, gensym {:arglists (quote ([] [prefix-string])), :method-params ([] [{:name prefix-string, :tag nil, :shadow nil}]), :name cljs.core/gensym, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :line 6802, :fn-var true, :file nil}, not= {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/not=, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Same as (not (= obj1 obj2))", :line 2174, :fn-var true, :file nil, :tag boolean}, *3 {:line 34, :file nil, :doc "bound in a repl thread to the third most recent value printed", :name cljs.core/*3}, Keyword {:line 1755, :file nil, :protocols #{cljs.core/IFn}, :num-fields 1, :type true, :name cljs.core/Keyword}, HashMap {:line 3685, :file nil, :protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/IAssociative cljs.core/ISeqable cljs.core/Object cljs.core/IMap cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 4, :type true, :name cljs.core/HashMap}, bit-or {:arglists (quote ([x y])), :method-params ([{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}]), :name cljs.core/bit-or, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Bitwise or", :line 1348, :fn-var true, :file nil}, hash-set {:arglists (quote ([] [& keys])), :method-params ([] [{:name keys, :tag nil, :shadow nil}]), :name cljs.core/hash-set, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :line 5764, :fn-var true, :file nil}, ILookup {:line 179, :file nil, :protocol-symbol true, :name cljs.core/ILookup}, -first {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/ISeq, :name cljs.core/-first, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 172, :fn-var true, :file nil}, fixture2 {:line 6815, :file nil, :name cljs.core/fixture2}, add-watch {:arglists (quote ([iref key f])), :method-params ([{:name iref, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil}]), :name cljs.core/add-watch, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Alpha - subject to change.\n\n  Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1", :line 6767, :fn-var true, :file nil}, some {:arglists (quote ([pred coll])), :method-params ([{:name pred, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/some, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :line 2199, :fn-var true, :file nil}, nil? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/nil?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if x is nil, false otherwise.", :line 48, :fn-var true, :file nil, :tag boolean}, push-tail {:arglists (quote ([pv level parent tailnode])), :method-params ([{:name pv, :tag nil, :shadow nil} {:name level, :tag nil, :shadow nil} {:name parent, :tag nil, :shadow nil} {:name tailnode, :tag nil, :shadow nil}]), :name cljs.core/push-tail, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :line 2867, :fn-var true, :file nil}, IndexedSeq {:line 559, :file nil, :protocols #{cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IIndexed cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/Object cljs.core/IReversible cljs.core/ASeq cljs.core/ISequential cljs.core/INext cljs.core/IReduce cljs.core/ISeq}, :num-fields 2, :type true, :name cljs.core/IndexedSeq}, Subvec {:line 3155, :file nil, :protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IVector cljs.core/IHash cljs.core/IIndexed cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/IAssociative cljs.core/ISeqable cljs.core/Object cljs.core/ISequential cljs.core/IReduce cljs.core/IStack cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 5, :type true, :name cljs.core/Subvec}, string? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/string?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1012, :fn-var true, :file nil, :tag boolean}, second {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/second, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Same as (first (next x))", :line 706, :fn-var true, :file nil}, keys {:arglists (quote ([hash-map])), :method-params ([{:name hash-map, :tag nil, :shadow nil}]), :name cljs.core/keys, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a sequence of the map's keys.", :line 5527, :fn-var true, :file nil}, *2 {:line 30, :file nil, :doc "bound in a repl thread to the second most recent value printed", :name cljs.core/*2}, long-array {:arglists (quote ([size-or-seq] [size init-val-or-seq])), :method-params ([{:name size-or-seq, :tag nil, :shadow nil}] [{:name size, :tag nil, :shadow nil} {:name init-val-or-seq, :tag nil, :shadow nil}]), :name cljs.core/long-array, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 1974, :fn-var true, :file nil}, hash-collision-node-find-index {:arglists (quote ([arr cnt key])), :method-params ([{:name arr, :tag nil, :shadow nil} {:name cnt, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil}]), :name cljs.core/hash-collision-node-find-index, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 4383, :fn-var true, :file nil}, tv-ensure-editable {:arglists (quote ([edit node])), :method-params ([{:name edit, :tag nil, :shadow nil} {:name node, :tag nil, :shadow nil}]), :name cljs.core/tv-ensure-editable, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 3243, :fn-var true, :file nil}, pv-aset {:arglists (quote ([node idx val])), :method-params ([{:name node, :tag nil, :shadow nil} {:name idx, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}]), :name cljs.core/pv-aset, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 2845, :fn-var true, :file nil}, bit-set {:arglists (quote ([x n])), :method-params ([{:name x, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}]), :name cljs.core/bit-set, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Set bit at index n", :line 1370, :fn-var true, :file nil}, IAssociative {:line 182, :file nil, :protocol-symbol true, :name cljs.core/IAssociative}, bit-count {:arglists (quote ([v])), :method-params ([{:name v, :tag nil, :shadow nil}]), :name cljs.core/bit-count, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Counts the number of bits set in n", :line 1392, :fn-var true, :file nil}, fixture1 {:line 6814, :file nil, :name cljs.core/fixture1}, char-escapes {:line 6353, :file nil, :private true, :name cljs.core/char-escapes}, long {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/long, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Coerce to long by stripping decimal places. Identical to `int'.", :line 1309, :fn-var true, :file nil}, Atom {:line 6646, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/IHash cljs.core/IWatchable cljs.core/IPrintWithWriter cljs.core/IDeref cljs.core/IPrintable}, :num-fields 4, :type true, :name cljs.core/Atom}, -sorted-seq-from {:arglists (quote ([coll k ascending?])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name ascending?, :tag nil, :shadow nil}]), :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq-from, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 244, :fn-var true, :file nil}, inode-kv-reduce {:arglists (quote ([arr f init])), :method-params ([{:name arr, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name init, :tag nil, :shadow nil}]), :name cljs.core/inode-kv-reduce, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 4058, :fn-var true, :file nil}, false? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/false?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if x is the value false, false otherwise.", :line 986, :fn-var true, :file nil, :tag boolean}, true? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/true?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if x is the value true, false otherwise.", :line 990, :fn-var true, :file nil, :tag boolean}, clone-and-set {:arglists (quote ([arr i a] [arr i a j b])), :method-params ([{:name arr, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil}] [{:name arr, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil}]), :name cljs.core/clone-and-set, :protocol-impl nil, :max-fixed-arity 5, :private true, :protocol-inline nil, :variadic false, :line 4026, :fn-var true, :file nil}, -notify-watches {:arglists (quote ([this oldval newval])), :method-params ([{:name this, :tag nil, :shadow nil} {:name oldval, :tag nil, :shadow nil} {:name newval, :tag nil, :shadow nil}]), :protocol cljs.core/IWatchable, :name cljs.core/-notify-watches, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 271, :fn-var true, :file nil}, do-dispatch {:arglists (quote ([mf dispatch-fn args])), :method-params ([{:name mf, :tag nil, :shadow nil} {:name dispatch-fn, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}]), :name cljs.core/do-dispatch, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 7094, :fn-var true, :file nil}, repeat {:arglists (quote ([x] [n x])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name n, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil}]), :name cljs.core/repeat, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :line 2537, :fn-var true, :file nil}, IFn {:line 131, :file nil, :protocol-symbol true, :name cljs.core/IFn}, zipmap {:arglists (quote ([keys vals])), :method-params ([{:name keys, :tag nil, :shadow nil} {:name vals, :tag nil, :shadow nil}]), :name cljs.core/zipmap, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a map with the keys mapped to the corresponding vals.", :line 5845, :fn-var true, :file nil}, distinct {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/distinct, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of the elements of coll with duplicates removed", :line 5804, :fn-var true, :file nil}, string-print {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/string-print, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 6180, :fn-var true, :file nil}, get-in {:arglists (quote ([m ks] [m ks not-found])), :method-params ([{:name m, :tag nil, :shadow nil} {:name ks, :tag nil, :shadow nil}] [{:name m, :tag nil, :shadow nil} {:name ks, :tag nil, :shadow nil} {:name not-found, :tag nil, :shadow nil}]), :name cljs.core/get-in, :protocol-impl nil, :max-fixed-arity 3, :added "1.2", :static true, :protocol-inline nil, :variadic false, :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :line 2701, :fn-var true, :file nil}, bit-xor {:arglists (quote ([x y])), :method-params ([{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}]), :name cljs.core/bit-xor, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Bitwise exclusive or", :line 1340, :fn-var true, :file nil}, complement {:arglists (quote ([f])), :method-params ([{:name f, :tag nil, :shadow nil}]), :name cljs.core/complement, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :line 2225, :fn-var true, :file nil, :tag boolean}, get-validator {:arglists (quote ([iref])), :method-params ([{:name iref, :tag nil, :shadow nil}]), :name cljs.core/get-validator, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Gets the validator-fn for a var/ref/agent/atom.", :line 6748, :fn-var true, :file nil}, seqable? {:arglists (quote ([s])), :method-params ([{:name s, :tag nil, :shadow nil}]), :name cljs.core/seqable?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Return true if s satisfies ISeqable", :line 1004, :fn-var true, :file nil, :tag boolean}, -dissoc {:arglists (quote ([coll k])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil}]), :protocol cljs.core/IMap, :name cljs.core/-dissoc, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 187, :fn-var true, :file nil}, js->clj {:arglists (quote ([x & options])), :method-params ([{:name x, :tag nil, :shadow nil} {:name options, :tag nil, :shadow nil}]), :name cljs.core/js->clj, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic true, :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :line 6847, :fn-var true, :file nil}, pop! {:arglists (quote ([tcoll])), :method-params ([{:name tcoll, :tag nil, :shadow nil}]), :name cljs.core/pop!, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 2106, :fn-var true, :file nil}, derive {:arglists (quote ([tag parent] [h tag parent])), :method-params ([{:name tag, :tag nil, :shadow nil} {:name parent, :tag nil, :shadow nil}] [{:name h, :tag nil, :shadow nil} {:name tag, :tag nil, :shadow nil} {:name parent, :tag nil, :shadow nil}]), :name cljs.core/derive, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :line 6977, :fn-var true, :file nil}, ChunkedCons {:line 1881, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IChunkedSeq cljs.core/IEmptyableCollection cljs.core/ISeqable cljs.core/ASeq cljs.core/ISequential cljs.core/IWithMeta cljs.core/IChunkedNext cljs.core/ISeq}, :num-fields 4, :type true, :name cljs.core/ChunkedCons}, PersistentTreeMap {:line 5357, :file nil, :protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/IKVReduce cljs.core/ISorted cljs.core/IAssociative cljs.core/ISeqable cljs.core/Object cljs.core/IReversible cljs.core/IMap cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 5, :type true, :name cljs.core/PersistentTreeMap}, bitpos {:arglists (quote ([hash shift])), :method-params ([{:name hash, :tag nil, :shadow nil} {:name shift, :tag nil, :shadow nil}]), :name cljs.core/bitpos, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 4044, :fn-var true, :file nil}, PersistentArrayMap {:line 3800, :file nil, :protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/IKVReduce cljs.core/IEditableCollection cljs.core/IAssociative cljs.core/ISeqable cljs.core/Object cljs.core/IMap cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 4, :type true, :name cljs.core/PersistentArrayMap}, prefers* {:arglists (quote ([x y prefer-table])), :method-params ([{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name prefer-table, :tag nil, :shadow nil}]), :name cljs.core/prefers*, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 7037, :fn-var true, :file nil}, partition-by {:arglists (quote ([f coll])), :method-params ([{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/partition-by, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Applies f to each value in coll, splitting it each time f returns\n   a new value.  Returns a lazy seq of partitions.", :line 6018, :fn-var true, :file nil}, rem {:arglists (quote ([n d])), :method-params ([{:name n, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil}]), :name cljs.core/rem, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "remainder of dividing numerator by denominator.", :line 1325, :fn-var true, :file nil}, PersistentQueue {:line 3464, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/Object cljs.core/ISequential cljs.core/IStack cljs.core/IWithMeta cljs.core/ISeq}, :num-fields 5, :type true, :name cljs.core/PersistentQueue}, -dispatch {:arglists (quote ([mf args])), :method-params ([{:name mf, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}]), :protocol cljs.core/IMultiFn, :name cljs.core/-dispatch, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 7084, :fn-var true, :file nil}, odd? {:arglists (quote ([n])), :method-params ([{:name n, :tag nil, :shadow nil}]), :name cljs.core/odd?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if n is odd, throws an exception if n is not an integer", :line 2219, :fn-var true, :file nil, :tag boolean}, create-tree-map-seq {:arglists (quote ([tree ascending? cnt])), :method-params ([{:name tree, :tag nil, :shadow nil} {:name ascending?, :tag nil, :shadow nil} {:name cnt, :tag nil, :shadow nil}]), :name cljs.core/create-tree-map-seq, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 4889, :fn-var true, :file nil}, symbol? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/symbol?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1021, :fn-var true, :file nil, :tag boolean}, mapv {:arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :method-params ([{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name c1, :tag nil, :shadow nil} {:name c2, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name c1, :tag nil, :shadow nil} {:name c2, :tag nil, :shadow nil} {:name c3, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name c1, :tag nil, :shadow nil} {:name c2, :tag nil, :shadow nil} {:name c3, :tag nil, :shadow nil} {:name colls, :tag nil, :shadow nil}]), :name cljs.core/mapv, :protocol-impl nil, :max-fixed-arity 4, :protocol-inline nil, :variadic true, :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :line 2654, :fn-var true, :file nil}, TransientHashMap {:protocols #{cljs.core/ICounted cljs.core/ITransientMap cljs.core/Object cljs.core/ITransientAssociative cljs.core/ITransientCollection cljs.core/ILookup}, :num-fields 5, :type true, :line 4732, :file nil, :declared true, :name cljs.core/TransientHashMap}, StringBufferWriter {:line 6187, :file nil, :protocols #{cljs.core/IWriter}, :num-fields 1, :type true, :name cljs.core/StringBufferWriter}, -assoc! {:arglists (quote ([tcoll key val])), :method-params ([{:name tcoll, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}]), :protocol cljs.core/ITransientAssociative, :name cljs.core/-assoc!, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 283, :fn-var true, :file nil}, js-obj {:arglists (quote ([] [& keyvals])), :method-params ([] [{:name keyvals, :tag nil, :shadow nil}]), :name cljs.core/js-obj, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :line 952, :fn-var true, :file nil}, filterv {:arglists (quote ([pred coll])), :method-params ([{:name pred, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/filterv, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a vector of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :line 2670, :fn-var true, :file nil}, -remove-watch {:arglists (quote ([this key])), :method-params ([{:name this, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil}]), :protocol cljs.core/IWatchable, :name cljs.core/-remove-watch, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 271, :fn-var true, :file nil}, str* {:arglists (quote ([] [x] [x & ys])), :method-params ([] [{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name ys, :tag nil, :shadow nil}]), :name cljs.core/str*, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic true, :doc "Internal - do not use!", :line 1435, :fn-var true, :file nil}, pv-clone-node {:arglists (quote ([node])), :method-params ([{:name node, :tag nil, :shadow nil}]), :name cljs.core/pv-clone-node, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 2848, :fn-var true, :file nil}, re-matches {:arglists (quote ([re s])), :method-params ([{:name re, :tag nil, :shadow nil} {:name s, :tag nil, :shadow nil}]), :name cljs.core/re-matches, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns the result of (re-find re s) if re fully matches s.", :line 6120, :fn-var true, :file nil}, split-with {:arglists (quote ([pred coll])), :method-params ([{:name pred, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/split-with, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", :line 6013, :fn-var true, :file nil}, add-to-string-hash-cache {:arglists (quote ([k])), :method-params ([{:name k, :tag nil, :shadow nil}]), :name cljs.core/add-to-string-hash-cache, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 883, :fn-var true, :file nil}, IChunk {:line 299, :file nil, :protocol-symbol true, :name cljs.core/IChunk}, tree-map-remove {:arglists (quote ([comp tree k found])), :method-params ([{:name comp, :tag nil, :shadow nil} {:name tree, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name found, :tag nil, :shadow nil}]), :name cljs.core/tree-map-remove, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :line 5326, :fn-var true, :file nil}, accumulating-seq-count {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/accumulating-seq-count, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 759, :fn-var true, :file nil}, spread {:arglists (quote ([arglist])), :method-params ([{:name arglist, :tag nil, :shadow nil}]), :name cljs.core/spread, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 2045, :fn-var true, :file nil}, next {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/next, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :line 345, :fn-var true, :file nil, :tag seq}, symbol {:arglists (quote ([name] [ns name])), :method-params ([{:name name, :tag nil, :shadow nil}] [{:name ns, :tag nil, :shadow nil} {:name name, :tag nil, :shadow nil}]), :name cljs.core/symbol, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a Symbol with the given namespace and name.", :line 1483, :fn-var true, :file nil}, vals {:arglists (quote ([hash-map])), :method-params ([{:name hash-map, :tag nil, :shadow nil}]), :name cljs.core/vals, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a sequence of the map's values.", :line 5537, :fn-var true, :file nil}, select-keys {:arglists (quote ([map keyseq])), :method-params ([{:name map, :tag nil, :shadow nil} {:name keyseq, :tag nil, :shadow nil}]), :name cljs.core/select-keys, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a map containing only those entries in map whose key is in keys", :line 5571, :fn-var true, :file nil}, reduceable? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/reduceable?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if coll satisfies IReduce", :line 933, :fn-var true, :file nil, :tag boolean}, rand {:arglists (quote ([] [n])), :method-params ([] [{:name n, :tag nil, :shadow nil}]), :name cljs.core/rand, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :line 6896, :fn-var true, :file nil}, deref {:arglists (quote ([o])), :method-params ([{:name o, :tag nil, :shadow nil}]), :name cljs.core/deref, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 6734, :fn-var true, :file nil}, tv-push-tail {:arglists (quote ([tv level parent tail-node])), :method-params ([{:name tv, :tag nil, :shadow nil} {:name level, :tag nil, :shadow nil} {:name parent, :tag nil, :shadow nil} {:name tail-node, :tag nil, :shadow nil}]), :name cljs.core/tv-push-tail, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :line 3256, :fn-var true, :file nil}, -get-method {:arglists (quote ([mf dispatch-val])), :method-params ([{:name mf, :tag nil, :shadow nil} {:name dispatch-val, :tag nil, :shadow nil}]), :protocol cljs.core/IMultiFn, :name cljs.core/-get-method, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 7084, :fn-var true, :file nil}, -compare {:arglists (quote ([x y])), :method-params ([{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}]), :protocol cljs.core/IComparable, :name cljs.core/-compare, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 296, :fn-var true, :file nil}, tail-off {:arglists (quote ([pv])), :method-params ([{:name pv, :tag nil, :shadow nil}]), :name cljs.core/tail-off, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 2851, :fn-var true, :file nil}, Box {:line 4014, :file nil, :protocols #{}, :num-fields 1, :type true, :name cljs.core/Box}, make-hierarchy {:arglists (quote ([])), :method-params ([]), :name cljs.core/make-hierarchy, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic false, :doc "Creates a hierarchy object for use with derive, isa? etc.", :line 6924, :fn-var true, :file nil}, balance-left-del {:arglists (quote ([key val del right])), :method-params ([{:name key, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil} {:name del, :tag nil, :shadow nil} {:name right, :tag nil, :shadow nil}]), :name cljs.core/balance-left-del, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :line 4941, :fn-var true, :file nil}, -disjoin! {:arglists (quote ([tcoll v])), :method-params ([{:name tcoll, :tag nil, :shadow nil} {:name v, :tag nil, :shadow nil}]), :protocol cljs.core/ITransientSet, :name cljs.core/-disjoin!, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 293, :fn-var true, :file nil}, + {:arglists (quote ([] [x] [x y] [x y & more])), :method-params ([] [{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/+, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns the sum of nums. (+) returns 0.", :line 1205, :fn-var true, :file nil}, number? {:arglists (quote ([n])), :method-params ([{:name n, :tag nil, :shadow nil}]), :name cljs.core/number?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1025, :fn-var true, :file nil, :tag boolean}, assoc! {:arglists (quote ([tcoll key val])), :method-params ([{:name tcoll, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}]), :name cljs.core/assoc!, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 2100, :fn-var true, :file nil}, descendants {:arglists (quote ([tag] [h tag])), :method-params ([{:name tag, :tag nil, :shadow nil}] [{:name h, :tag nil, :shadow nil} {:name tag, :tag nil, :shadow nil}]), :name cljs.core/descendants, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :line 6968, :fn-var true, :file nil}, is_proto_ {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/is_proto_, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 68, :fn-var true, :file nil}, linear-traversal-nth {:arglists (quote ([coll n] [coll n not-found])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}] [{:name coll, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil} {:name not-found, :tag nil, :shadow nil}]), :name cljs.core/linear-traversal-nth, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 773, :fn-var true, :file nil}, into-array {:arglists (quote ([aseq] [type aseq])), :method-params ([{:name aseq, :tag nil, :shadow nil}] [{:name type, :tag nil, :shadow nil} {:name aseq, :tag nil, :shadow nil}]), :name cljs.core/into-array, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 123, :fn-var true, :file nil}, last {:arglists (quote ([s])), :method-params ([{:name s, :tag nil, :shadow nil}]), :name cljs.core/last, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Return the last item in coll, in linear time", :line 731, :fn-var true, :file nil}, some-fn {:arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :method-params ([{:name p, :tag nil, :shadow nil}] [{:name p1, :tag nil, :shadow nil} {:name p2, :tag nil, :shadow nil}] [{:name p1, :tag nil, :shadow nil} {:name p2, :tag nil, :shadow nil} {:name p3, :tag nil, :shadow nil}] [{:name p1, :tag nil, :shadow nil} {:name p2, :tag nil, :shadow nil} {:name p3, :tag nil, :shadow nil} {:name ps, :tag nil, :shadow nil}]), :name cljs.core/some-fn, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic true, :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :line 2406, :fn-var true, :file nil}, integer? {:arglists (quote ([n])), :method-params ([{:name n, :tag nil, :shadow nil}]), :name cljs.core/integer?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if n is an integer.", :line 1034, :fn-var true, :file nil, :tag boolean}, LazySeq {:line 1796, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ISeqable cljs.core/Object cljs.core/ISequential cljs.core/INext cljs.core/IWithMeta cljs.core/ISeq}, :num-fields 4, :type true, :name cljs.core/LazySeq}, reduced? {:arglists (quote ([r])), :method-params ([{:name r, :tag nil, :shadow nil}]), :name cljs.core/reduced?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if x is the result of a call to reduced", :line 480, :fn-var true, :file nil, :tag boolean}, editable-array-for {:arglists (quote ([tv i])), :method-params ([{:name tv, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil}]), :name cljs.core/editable-array-for, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 3282, :fn-var true, :file nil}, MultiFn {:line 7102, :file nil, :protocols #{cljs.core/IHash cljs.core/IMultiFn}, :num-fields 8, :type true, :name cljs.core/MultiFn}, -prefers {:arglists (quote ([mf])), :method-params ([{:name mf, :tag nil, :shadow nil}]), :protocol cljs.core/IMultiFn, :name cljs.core/-prefers, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 7084, :fn-var true, :file nil}, prn {:arglists (quote ([& objs])), :method-params ([{:name objs, :tag nil, :shadow nil}]), :name cljs.core/prn, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "Same as pr followed by (newline).", :line 6342, :fn-var true, :file nil}, with-meta {:arglists (quote ([o meta])), :method-params ([{:name o, :tag nil, :shadow nil} {:name meta, :tag nil, :shadow nil}]), :name cljs.core/with-meta, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :line 842, :fn-var true, :file nil}, -add-watch {:arglists (quote ([this key f])), :method-params ([{:name this, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil}]), :protocol cljs.core/IWatchable, :name cljs.core/-add-watch, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 271, :fn-var true, :file nil}, TransientHashSet {:protocols #{cljs.core/IFn cljs.core/ICounted cljs.core/ITransientSet cljs.core/ITransientCollection cljs.core/ILookup}, :num-fields 1, :type true, :line 5656, :file nil, :declared true, :name cljs.core/TransientHashSet}, * {:arglists (quote ([] [x] [x y] [x y & more])), :method-params ([] [{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/*, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns the product of nums. (*) returns 1.", :line 1219, :fn-var true, :file nil}, butlast {:arglists (quote ([s])), :method-params ([{:name s, :tag nil, :shadow nil}]), :name cljs.core/butlast, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 5818, :fn-var true, :file nil}, RSeq {:protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/Object cljs.core/ISequential cljs.core/IWithMeta cljs.core/ISeq}, :num-fields 3, :type true, :line 667, :file nil, :declared true, :name cljs.core/RSeq}, - {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/-, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :line 1212, :fn-var true, :file nil}, lookup-sentinel {:line 984, :file nil, :private true, :name cljs.core/lookup-sentinel}, -empty {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/IEmptyableCollection, :name cljs.core/-empty, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 158, :fn-var true, :file nil}, NeverEquiv {:line 3515, :file nil, :protocols #{cljs.core/IEquiv}, :num-fields 0, :type true, :name cljs.core/NeverEquiv}, reversible? {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/reversible?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1653, :fn-var true, :file nil, :tag boolean}, rseq {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/rseq, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1656, :fn-var true, :file nil}, flatten1 {:arglists (quote ([colls])), :method-params ([{:name colls, :tag nil, :shadow nil}]), :name cljs.core/flatten1, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection", :line 2578, :fn-var true, :file nil}, seq? {:arglists (quote ([s])), :method-params ([{:name s, :tag nil, :shadow nil}]), :name cljs.core/seq?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Return true if s satisfies ISeq", :line 997, :fn-var true, :file nil, :tag boolean}, ci-reduce {:arglists (quote ([cicoll f] [cicoll f val] [cicoll f val idx])), :method-params ([{:name cicoll, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil}] [{:name cicoll, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}] [{:name cicoll, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil} {:name idx, :tag nil, :shadow nil}]), :name cljs.core/ci-reduce, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :line 485, :fn-var true, :file nil}, pack-array-node {:arglists (quote ([array-node edit idx])), :method-params ([{:name array-node, :tag nil, :shadow nil} {:name edit, :tag nil, :shadow nil} {:name idx, :tag nil, :shadow nil}]), :name cljs.core/pack-array-node, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 4274, :fn-var true, :file nil}, identical? {:arglists (quote ([x y])), :method-params ([{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}]), :name cljs.core/identical?, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Tests if 2 arguments are the same object", :line 43, :fn-var true, :file nil, :tag boolean}, print {:method-params ([{:name objs, :tag nil, :shadow nil}]), :name cljs.core/print, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption.", :line 6319, :fn-var true, :file nil}, pr-sequential {:arglists (quote ([print-one begin sep end opts coll])), :method-params ([{:name print-one, :tag nil, :shadow nil} {:name begin, :tag nil, :shadow nil} {:name sep, :tag nil, :shadow nil} {:name end, :tag nil, :shadow nil} {:name opts, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/pr-sequential, :protocol-impl nil, :max-fixed-arity 6, :deprecated true, :protocol-inline nil, :variadic false, :doc "Do not use this.  It is kept for backwards compatibility with the\n   old IPrintable protocol.", :line 6158, :fn-var true, :file nil}, vary-meta {:arglists (quote ([obj f & args])), :method-params ([{:name obj, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}]), :name cljs.core/vary-meta, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :line 2168, :fn-var true, :file nil}, PersistentTreeSet {:line 5693, :file nil, :protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISorted cljs.core/ISeqable cljs.core/ISet cljs.core/Object cljs.core/IReversible cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 3, :type true, :name cljs.core/PersistentTreeSet}, bit-flip {:arglists (quote ([x n])), :method-params ([{:name x, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}]), :name cljs.core/bit-flip, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Flip bit at index n", :line 1361, :fn-var true, :file nil}, zero? {:arglists (quote ([n])), :method-params ([{:name n, :tag nil, :shadow nil}]), :name cljs.core/zero?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1416, :fn-var true, :file nil, :tag boolean}, bit-and {:arglists (quote ([x y])), :method-params ([{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}]), :name cljs.core/bit-and, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Bitwise and", :line 1344, :fn-var true, :file nil}, key-test {:arglists (quote ([key other])), :method-params ([{:name key, :tag nil, :shadow nil} {:name other, :tag nil, :shadow nil}]), :name cljs.core/key-test, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 4018, :fn-var true, :file nil, :tag boolean}, pr-seq {:arglists (quote ([obj opts])), :method-params ([{:name obj, :tag nil, :shadow nil} {:name opts, :tag nil, :shadow nil}]), :name cljs.core/pr-seq, :protocol-impl nil, :max-fixed-arity 2, :deprecated true, :private true, :protocol-inline nil, :variadic false, :doc "Do not use this.  It is kept for backwards compatibility with the\n   old IPrintable protocol.", :line 6192, :fn-var true, :file nil}, -comparator {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/ISorted, :name cljs.core/-comparator, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 244, :fn-var true, :file nil}, newline {:arglists (quote ([opts])), :method-params ([{:name opts, :tag nil, :shadow nil}]), :name cljs.core/newline, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 6285, :fn-var true, :file nil}, IDeref {:line 205, :file nil, :protocol-symbol true, :name cljs.core/IDeref}, edit-and-set {:arglists (quote ([inode edit i a] [inode edit i a j b])), :method-params ([{:name inode, :tag nil, :shadow nil} {:name edit, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil}] [{:name inode, :tag nil, :shadow nil} {:name edit, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil}]), :name cljs.core/edit-and-set, :protocol-impl nil, :max-fixed-arity 6, :private true, :protocol-inline nil, :variadic false, :line 4047, :fn-var true, :file nil}, replicate {:arglists (quote ([n x])), :method-params ([{:name n, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil}]), :name cljs.core/replicate, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy seq of n xs.", :line 2542, :fn-var true, :file nil}, balance-right-del {:arglists (quote ([key val left del])), :method-params ([{:name key, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil} {:name left, :tag nil, :shadow nil} {:name del, :tag nil, :shadow nil}]), :name cljs.core/balance-right-del, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :line 4960, :fn-var true, :file nil}, keep-indexed {:arglists (quote ([f coll])), :method-params ([{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/keep-indexed, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.", :line 2344, :fn-var true, :file nil}, distinct? {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/distinct?, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns true if no two of the arguments are =", :line 1061, :fn-var true, :file nil, :tag boolean}, vec {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/vec, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 3077, :fn-var true, :file nil}, tree-map-replace {:arglists (quote ([comp tree k v])), :method-params ([{:name comp, :tag nil, :shadow nil} {:name tree, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name v, :tag nil, :shadow nil}]), :name cljs.core/tree-map-replace, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :line 5348, :fn-var true, :file nil}, -equiv {:arglists (quote ([o other])), :method-params ([{:name o, :tag nil, :shadow nil} {:name other, :tag nil, :shadow nil}]), :protocol cljs.core/IEquiv, :name cljs.core/-equiv, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 223, :fn-var true, :file nil}, obj-map-compare-keys {:arglists (quote ([a b])), :method-params ([{:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil}]), :name cljs.core/obj-map-compare-keys, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 3549, :fn-var true, :file nil}, concat {:arglists (quote ([] [x] [x y] [x y & zs])), :method-params ([] [{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name zs, :tag nil, :shadow nil}]), :name cljs.core/concat, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :line 2053, :fn-var true, :file nil}, update-in {:arglists (quote ([m [k & ks] f & args])), :method-params ([{:name m, :tag nil, :shadow nil} {:name p__3179, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}]), :name cljs.core/update-in, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic true, :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :line 2729, :fn-var true, :file nil}, vector {:arglists (quote ([& args])), :method-params ([{:name args, :tag nil, :shadow nil}]), :name cljs.core/vector, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :line 3083, :fn-var true, :file nil}, seq-reduce {:arglists (quote ([f coll] [f val coll])), :method-params ([{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/seq-reduce, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 1150, :fn-var true, :file nil}, conj {:arglists (quote ([coll x] [coll x & xs])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil}] [{:name coll, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name xs, :tag nil, :shadow nil}]), :name cljs.core/conj, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).  The 'addition' may\n  happen at different 'places' depending on the concrete type.", :line 743, :fn-var true, :file nil}, find-and-cache-best-method {:arglists (quote ([name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy])), :method-params ([{:name name, :tag nil, :shadow nil} {:name dispatch-val, :tag nil, :shadow nil} {:name hierarchy, :tag nil, :shadow nil} {:name method-table, :tag nil, :shadow nil} {:name prefer-table, :tag nil, :shadow nil} {:name method-cache, :tag nil, :shadow nil} {:name cached-hierarchy, :tag nil, :shadow nil}]), :name cljs.core/find-and-cache-best-method, :protocol-impl nil, :max-fixed-arity 7, :private true, :protocol-inline nil, :variadic false, :line 7059, :fn-var true, :file nil}, / {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name (symbol "cljs.core" "/"), :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :line 1226, :fn-var true, :file nil}, assoc {:arglists (quote ([coll k v] [coll k v & kvs])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name v, :tag nil, :shadow nil}] [{:name coll, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name v, :tag nil, :shadow nil} {:name kvs, :tag nil, :shadow nil}]), :name cljs.core/assoc, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic true, :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index.", :line 817, :fn-var true, :file nil}, fix {:arglists (quote ([q])), :method-params ([{:name q, :tag nil, :shadow nil}]), :name cljs.core/fix, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 1299, :fn-var true, :file nil}, -nth {:arglists (quote ([coll n] [coll n not-found])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}] [{:name coll, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil} {:name not-found, :tag nil, :shadow nil}]), :protocol cljs.core/IIndexed, :name cljs.core/-nth, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 167, :fn-var true, :file nil}, boolean {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/boolean, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1009, :fn-var true, :file nil, :tag boolean}, neg? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/neg?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if num is less than zero, else false", :line 1419, :fn-var true, :file nil, :tag boolean}, ISequential {:line 232, :file nil, :protocol-symbol true, :name cljs.core/ISequential}, js-delete {:arglists (quote ([obj key])), :method-params ([{:name obj, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil}]), :name cljs.core/js-delete, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 963, :fn-var true, :file nil}, -reset {:arglists (quote ([mf])), :method-params ([{:name mf, :tag nil, :shadow nil}]), :protocol cljs.core/IMultiFn, :name cljs.core/-reset, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 7084, :fn-var true, :file nil}, isa? {:arglists (quote ([child parent] [h child parent])), :method-params ([{:name child, :tag nil, :shadow nil} {:name parent, :tag nil, :shadow nil}] [{:name h, :tag nil, :shadow nil} {:name child, :tag nil, :shadow nil} {:name parent, :tag nil, :shadow nil}]), :name cljs.core/isa?, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :line 6932, :fn-var true, :file nil, :tag boolean}, -deref-with-timeout {:arglists (quote ([o msec timeout-val])), :method-params ([{:name o, :tag nil, :shadow nil} {:name msec, :tag nil, :shadow nil} {:name timeout-val, :tag nil, :shadow nil}]), :protocol cljs.core/IDerefWithTimeout, :name cljs.core/-deref-with-timeout, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 208, :fn-var true, :file nil}, -pr-writer {:arglists (quote ([o writer opts])), :method-params ([{:name o, :tag nil, :shadow nil} {:name writer, :tag nil, :shadow nil} {:name opts, :tag nil, :shadow nil}]), :protocol cljs.core/IPrintWithWriter, :name cljs.core/-pr-writer, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 260, :fn-var true, :file nil}, -kv-reduce {:arglists (quote ([coll f init])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name init, :tag nil, :shadow nil}]), :protocol cljs.core/IKVReduce, :name cljs.core/-kv-reduce, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 220, :fn-var true, :file nil}, remove-watch {:arglists (quote ([iref key])), :method-params ([{:name iref, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil}]), :name cljs.core/remove-watch, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Alpha - subject to change.\n\n  Removes a watch (set by add-watch) from a reference", :line 6791, :fn-var true, :file nil}, print-str {:arglists (quote ([& objs])), :method-params ([{:name objs, :tag nil, :shadow nil}]), :name cljs.core/print-str, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "print to a string, returning it", :line 6326, :fn-var true, :file nil}, rsubseq {:arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :method-params ([{:name sc, :tag nil, :shadow nil} {:name test, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil}] [{:name sc, :tag nil, :shadow nil} {:name start-test, :tag nil, :shadow nil} {:name start-key, :tag nil, :shadow nil} {:name end-test, :tag nil, :shadow nil} {:name end-key, :tag nil, :shadow nil}]), :name cljs.core/rsubseq, :protocol-impl nil, :max-fixed-arity 5, :protocol-inline nil, :variadic false, :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :line 5911, :fn-var true, :file nil}, *flush-on-newline* {:line 6290, :file nil, :name cljs.core/*flush-on-newline*}, HashCollisionNode {:line 4392, :file nil, :protocols #{cljs.core/Object}, :num-fields 4, :type true, :name cljs.core/HashCollisionNode}, vector? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/vector?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Return true if x satisfies IVector", :line 944, :fn-var true, :file nil, :tag boolean}, split-at {:arglists (quote ([n coll])), :method-params ([{:name n, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/split-at, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a vector of [(take n coll) (drop n coll)]", :line 2532, :fn-var true, :file nil}, chunk-cons {:arglists (quote ([chunk rest])), :method-params ([{:name chunk, :tag nil, :shadow nil} {:name rest, :tag nil, :shadow nil}]), :name cljs.core/chunk-cons, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 1929, :fn-var true, :file nil}, mk-bound-fn {:arglists (quote ([sc test key])), :method-params ([{:name sc, :tag nil, :shadow nil} {:name test, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil}]), :name cljs.core/mk-bound-fn, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 5890, :fn-var true, :file nil}, map {:arglists (quote ([f coll] [f c1 c2] [f c1 c2 c3] [f c1 c2 c3 & colls])), :method-params ([{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name c1, :tag nil, :shadow nil} {:name c2, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name c1, :tag nil, :shadow nil} {:name c2, :tag nil, :shadow nil} {:name c3, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name c1, :tag nil, :shadow nil} {:name c2, :tag nil, :shadow nil} {:name c3, :tag nil, :shadow nil} {:name colls, :tag nil, :shadow nil}]), :name cljs.core/map, :protocol-impl nil, :max-fixed-arity 4, :protocol-inline nil, :variadic true, :doc "Returns a lazy sequence consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :line 2445, :fn-var true, :file nil}, INext {:line 176, :file nil, :protocol-symbol true, :name cljs.core/INext}, -as-transient {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/IEditableCollection, :name cljs.core/-as-transient, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 276, :fn-var true, :file nil}, counted? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/counted?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if coll implements count in constant time", :line 551, :fn-var true, :file nil, :tag boolean}, double-array {:arglists (quote ([size-or-seq] [size init-val-or-seq])), :method-params ([{:name size-or-seq, :tag nil, :shadow nil}] [{:name size, :tag nil, :shadow nil} {:name init-val-or-seq, :tag nil, :shadow nil}]), :name cljs.core/double-array, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 1995, :fn-var true, :file nil}, IPrintWithWriter {:line 260, :file nil, :protocol-symbol true, :name cljs.core/IPrintWithWriter}, IKVReduce {:line 220, :file nil, :protocol-symbol true, :name cljs.core/IKVReduce}, NodeSeq {:line 4508, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ISeqable cljs.core/Object cljs.core/ISequential cljs.core/IWithMeta cljs.core/ISeq}, :num-fields 5, :type true, :name cljs.core/NodeSeq}, frequencies {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/frequencies, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a map from distinct items in coll to the number of times\n  they appear.", :line 6029, :fn-var true, :file nil}, rand-int {:arglists (quote ([n])), :method-params ([{:name n, :tag nil, :shadow nil}]), :name cljs.core/rand-int, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a random integer between 0 (inclusive) and n (exclusive).", :line 6902, :fn-var true, :file nil}, -add-method {:arglists (quote ([mf dispatch-val method])), :method-params ([{:name mf, :tag nil, :shadow nil} {:name dispatch-val, :tag nil, :shadow nil} {:name method, :tag nil, :shadow nil}]), :protocol cljs.core/IMultiFn, :name cljs.core/-add-method, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 7084, :fn-var true, :file nil}, *1 {:line 26, :file nil, :doc "bound in a repl thread to the most recent value printed", :name cljs.core/*1}, prn-str {:arglists (quote ([& objs])), :method-params ([{:name objs, :tag nil, :shadow nil}]), :name cljs.core/prn-str, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "Same as pr-str followed by (newline)", :line 6306, :fn-var true, :file nil}, iterate {:arglists (quote ([f x])), :method-params ([{:name f, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil}]), :name cljs.core/iterate, :protocol-impl nil, :max-fixed-arity 2, :added "1.0", :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :line 2553, :fn-var true, :file nil}, IRecord {:line 238, :file nil, :protocol-symbol true, :name cljs.core/IRecord}, chunk-append {:arglists (quote ([b x])), :method-params ([{:name b, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil}]), :name cljs.core/chunk-append, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 1934, :fn-var true, :file nil}, mapcat {:arglists (quote ([f coll] [f coll & colls])), :method-params ([{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil} {:name colls, :tag nil, :shadow nil}]), :name cljs.core/mapcat, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection.", :line 2590, :fn-var true, :file nil}, ICollection {:line 161, :file nil, :protocol-symbol true, :name cljs.core/ICollection}, assoc-in {:arglists (quote ([m [k & ks] v])), :method-params ([{:name m, :tag nil, :shadow nil} {:name p__3172, :tag nil, :shadow nil} {:name v, :tag nil, :shadow nil}]), :name cljs.core/assoc-in, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :line 2720, :fn-var true, :file nil}, conj! {:arglists (quote ([tcoll val])), :method-params ([{:name tcoll, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}]), :name cljs.core/conj!, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 2097, :fn-var true, :file nil}, inc {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/inc, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a number one greater than num.", :line 465, :fn-var true, :file nil}, RedNode {:protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IVector cljs.core/IHash cljs.core/IIndexed cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/IAssociative cljs.core/ISeqable cljs.core/Object cljs.core/IMapEntry cljs.core/ISequential cljs.core/IReduce cljs.core/IStack cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 5, :type true, :line 5103, :file nil, :declared true, :name cljs.core/RedNode}, ASeq {:line 170, :file nil, :protocol-symbol true, :name cljs.core/ASeq}, every-pred {:arglists (quote ([p] [p1 p2] [p1 p2 p3] [p1 p2 p3 & ps])), :method-params ([{:name p, :tag nil, :shadow nil}] [{:name p1, :tag nil, :shadow nil} {:name p2, :tag nil, :shadow nil}] [{:name p1, :tag nil, :shadow nil} {:name p2, :tag nil, :shadow nil} {:name p3, :tag nil, :shadow nil}] [{:name p1, :tag nil, :shadow nil} {:name p2, :tag nil, :shadow nil} {:name p3, :tag nil, :shadow nil} {:name ps, :tag nil, :shadow nil}]), :name cljs.core/every-pred, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic true, :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :line 2367, :fn-var true, :file nil}, IReversible {:line 241, :file nil, :protocol-symbol true, :name cljs.core/IReversible}, -realized? {:arglists (quote ([d])), :method-params ([{:name d, :tag nil, :shadow nil}]), :protocol cljs.core/IPending, :name cljs.core/-realized?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 268, :fn-var true, :file nil}, array-chunk {:arglists (quote ([arr] [arr off] [arr off end])), :method-params ([{:name arr, :tag nil, :shadow nil}] [{:name arr, :tag nil, :shadow nil} {:name off, :tag nil, :shadow nil}] [{:name arr, :tag nil, :shadow nil} {:name off, :tag nil, :shadow nil} {:name end, :tag nil, :shadow nil}]), :name cljs.core/array-chunk, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 1873, :fn-var true, :file nil}, create-array-node-seq {:arglists (quote ([nodes] [meta nodes i s])), :method-params ([{:name nodes, :tag nil, :shadow nil}] [{:name meta, :tag nil, :shadow nil} {:name nodes, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name s, :tag nil, :shadow nil}]), :name cljs.core/create-array-node-seq, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :line 4606, :fn-var true, :file nil}, ChunkedSeq {:line 3085, :file nil, :protocols #{cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IChunkedSeq cljs.core/IEmptyableCollection cljs.core/ISeqable cljs.core/ASeq cljs.core/ISequential cljs.core/INext cljs.core/IWithMeta cljs.core/IChunkedNext cljs.core/ISeq}, :num-fields 6, :type true, :name cljs.core/ChunkedSeq}, chunked-seq {:arglists (quote ([vec i off] [vec node i off] [vec node i off meta])), :method-params ([{:name vec, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name off, :tag nil, :shadow nil}] [{:name vec, :tag nil, :shadow nil} {:name node, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name off, :tag nil, :shadow nil}] [{:name vec, :tag nil, :shadow nil} {:name node, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name off, :tag nil, :shadow nil} {:name meta, :tag nil, :shadow nil}]), :name cljs.core/chunked-seq, :protocol-impl nil, :max-fixed-arity 5, :protocol-inline nil, :variadic false, :line 3149, :fn-var true, :file nil}, shuffle {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/shuffle, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Return a random permutation of coll", :line 1166, :fn-var true, :file nil}, re-find {:arglists (quote ([re s])), :method-params ([{:name re, :tag nil, :shadow nil} {:name s, :tag nil, :shadow nil}]), :name cljs.core/re-find, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups.", :line 6129, :fn-var true, :file nil}, BitmapIndexedNode {:line 4076, :file nil, :protocols #{cljs.core/Object}, :num-fields 3, :type true, :name cljs.core/BitmapIndexedNode}, bit-not {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/bit-not, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Bitwise complement", :line 1366, :fn-var true, :file nil}, IMapEntry {:line 191, :file nil, :protocol-symbol true, :name cljs.core/IMapEntry}, seq {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/seq, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :line 311, :fn-var true, :file nil, :tag seq}, to-array-2d {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/to-array-2d, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :line 1963, :fn-var true, :file nil}, sorted-map-by {:arglists (quote ([comparator & keyvals])), :method-params ([{:name comparator, :tag nil, :shadow nil} {:name keyvals, :tag nil, :shadow nil}]), :name cljs.core/sorted-map-by, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic true, :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :line 5517, :fn-var true, :file nil}, filter {:arglists (quote ([pred coll])), :method-params ([{:name pred, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/filter, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns true. pred must be free of side-effects.", :line 2598, :fn-var true, :file nil}, -key {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/IMapEntry, :name cljs.core/-key, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 191, :fn-var true, :file nil}, bounded-count {:arglists (quote ([s n])), :method-params ([{:name s, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}]), :name cljs.core/bounded-count, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 2037, :fn-var true, :file nil}, js-keys {:arglists (quote ([obj])), :method-params ([{:name obj, :tag nil, :shadow nil}]), :name cljs.core/js-keys, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 958, :fn-var true, :file nil}, alter-meta! {:arglists (quote ([iref f & args])), :method-params ([{:name iref, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}]), :name cljs.core/alter-meta!, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :line 6753, :fn-var true, :file nil}, key {:arglists (quote ([map-entry])), :method-params ([{:name map-entry, :tag nil, :shadow nil}]), :name cljs.core/key, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns the key of the map entry.", :line 5532, :fn-var true, :file nil}, -seq {:arglists (quote ([o])), :method-params ([{:name o, :tag nil, :shadow nil}]), :protocol cljs.core/ISeqable, :name cljs.core/-seq, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 229, :fn-var true, :file nil}, equiv-map {:arglists (quote ([x y])), :method-params ([{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}]), :name cljs.core/equiv-map, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :doc "Assumes y is a map. Returns true if x equals y, otherwise returns\n  false.", :line 3521, :fn-var true, :file nil}, re-seq {:arglists (quote ([re s])), :method-params ([{:name re, :tag nil, :shadow nil} {:name s, :tag nil, :shadow nil}]), :name cljs.core/re-seq, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of successive matches of re in s.", :line 6141, :fn-var true, :file nil}, empty? {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/empty?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :line 905, :fn-var true, :file nil, :tag boolean}, ITransientSet {:line 293, :file nil, :protocol-symbol true, :name cljs.core/ITransientSet}, name {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/name, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns the name String of a string, symbol or keyword.", :line 5824, :fn-var true, :file nil}, list? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/list?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1720, :fn-var true, :file nil, :tag boolean}, global-hierarchy {:line 6928, :file nil, :private true, :name cljs.core/global-hierarchy}, pr-opts {:arglists (quote ([])), :method-params ([]), :name cljs.core/pr-opts, :protocol-impl nil, :max-fixed-arity 0, :private true, :protocol-inline nil, :variadic false, :line 6295, :fn-var true, :file nil}, aset {:arglists (quote ([array i val])), :method-params ([{:name array, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}]), :name cljs.core/aset, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Sets the value at the index.", :line 111, :fn-var true, :file nil}, nnext {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/nnext, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Same as (next (next x))", :line 726, :fn-var true, :file nil}, bit-shift-right-zero-fill {:arglists (quote ([x n])), :method-params ([{:name x, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}]), :name cljs.core/bit-shift-right-zero-fill, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Bitwise shift right with zero fill", :line 1388, :fn-var true, :file nil}, doall {:arglists (quote ([coll] [n coll])), :method-params ([{:name coll, :tag nil, :shadow nil}] [{:name n, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/doall, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :line 6101, :fn-var true, :file nil}, not-any? {:arglists (quote ([pred coll])), :method-params ([{:name pred, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/not-any?, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :line 2208, :fn-var true, :file nil, :tag boolean}, PersistentHashMap {:line 4622, :file nil, :protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/IKVReduce cljs.core/IEditableCollection cljs.core/IAssociative cljs.core/ISeqable cljs.core/Object cljs.core/IMap cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 6, :type true, :name cljs.core/PersistentHashMap}, reductions {:arglists (quote ([f coll] [f init coll])), :method-params ([{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name init, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/reductions, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :line 6038, :fn-var true, :file nil}, IWatchable {:line 271, :file nil, :protocol-symbol true, :name cljs.core/IWatchable}, into {:arglists (quote ([to from])), :method-params ([{:name to, :tag nil, :shadow nil} {:name from, :tag nil, :shadow nil}]), :name cljs.core/into, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined.", :line 2646, :fn-var true, :file nil}, tv-pop-tail {:arglists (quote ([tv level node])), :method-params ([{:name tv, :tag nil, :shadow nil} {:name level, :tag nil, :shadow nil} {:name node, :tag nil, :shadow nil}]), :name cljs.core/tv-pop-tail, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 3268, :fn-var true, :file nil}, transient {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/transient, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 2091, :fn-var true, :file nil}, ffirst {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/ffirst, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Same as (first (first x))", :line 711, :fn-var true, :file nil}, bit-clear {:arglists (quote ([x n])), :method-params ([{:name x, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}]), :name cljs.core/bit-clear, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Clear bit at index n", :line 1356, :fn-var true, :file nil}, pr-sb-with-opts {:arglists (quote ([objs opts])), :method-params ([{:name objs, :tag nil, :shadow nil} {:name opts, :tag nil, :shadow nil}]), :name cljs.core/pr-sb-with-opts, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 6255, :fn-var true, :file nil}, hash {:arglists (quote ([o] [o check-cache])), :method-params ([{:name o, :tag nil, :shadow nil}] [{:name o, :tag nil, :shadow nil} {:name check-cache, :tag boolean, :shadow nil}]), :name cljs.core/hash, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 898, :fn-var true, :file nil}, Vector {:line 2744, :file nil, :protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IVector cljs.core/IHash cljs.core/IIndexed cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/IAssociative cljs.core/ISeqable cljs.core/Object cljs.core/ISequential cljs.core/IReduce cljs.core/IStack cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 3, :type true, :name cljs.core/Vector}, gensym_counter {:line 6800, :file nil, :name cljs.core/gensym_counter}, compare-indexed {:arglists (quote ([xs ys] [xs ys len n])), :method-params ([{:name xs, :tag nil, :shadow nil} {:name ys, :tag nil, :shadow nil}] [{:name xs, :tag nil, :shadow nil} {:name ys, :tag nil, :shadow nil} {:name len, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}]), :name cljs.core/compare-indexed, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :doc "Compare indexed collection.", :line 1094, :fn-var true, :file nil}, IPending {:line 268, :file nil, :protocol-symbol true, :name cljs.core/IPending}, associative? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/associative?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if coll implements Associative", :line 925, :fn-var true, :file nil, :tag boolean}, type_satisfies_ {:arglists (quote ([p x])), :method-params ([{:name p, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil}]), :name cljs.core/type_satisfies_, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Internal - do not use!", :line 58, :fn-var true, :file nil, :tag boolean}, Delay {:line 6819, :file nil, :protocols #{cljs.core/IDeref cljs.core/IPending}, :num-fields 2, :type true, :name cljs.core/Delay}, tv-editable-tail {:arglists (quote ([tl])), :method-params ([{:name tl, :tag nil, :shadow nil}]), :name cljs.core/tv-editable-tail, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 3251, :fn-var true, :file nil}, scan-array {:arglists (quote ([incr k array])), :method-params ([{:name incr, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name array, :tag nil, :shadow nil}]), :name cljs.core/scan-array, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 3535, :fn-var true, :file nil}, drop-last {:arglists (quote ([s] [n s])), :method-params ([{:name s, :tag nil, :shadow nil}] [{:name n, :tag nil, :shadow nil} {:name s, :tag nil, :shadow nil}]), :name cljs.core/drop-last, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :line 2501, :fn-var true, :file nil}, replace {:arglists (quote ([smap coll])), :method-params ([{:name smap, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/replace, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap", :line 5790, :fn-var true, :file nil}, ArrayChunk {:protocols #{cljs.core/IIndexed cljs.core/ICounted cljs.core/IReduce cljs.core/IChunk}, :num-fields 3, :type true, :line 1849, :file nil, :declared true, :name cljs.core/ArrayChunk}, parents {:arglists (quote ([tag] [h tag])), :method-params ([{:name tag, :tag nil, :shadow nil}] [{:name h, :tag nil, :shadow nil} {:name tag, :tag nil, :shadow nil}]), :name cljs.core/parents, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :line 6952, :fn-var true, :file nil}, map? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/map?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Return true if x satisfies IMap", :line 937, :fn-var true, :file nil, :tag boolean}, prefers {:arglists (quote ([multifn])), :method-params ([{:name multifn, :tag nil, :shadow nil}]), :name cljs.core/prefers, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Given a multimethod, returns a map of preferred value -> set of other values", :line 7186, :fn-var true, :file nil}, quot {:arglists (quote ([n d])), :method-params ([{:name n, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil}]), :name cljs.core/quot, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "quot[ient] of dividing numerator by denominator.", :line 1319, :fn-var true, :file nil}, chunk-rest {:arglists (quote ([s])), :method-params ([{:name s, :tag nil, :shadow nil}]), :name cljs.core/chunk-rest, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1943, :fn-var true, :file nil}, reverse {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/reverse, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a seq of the items in coll in reverse order. Not lazy.", :line 1659, :fn-var true, :file nil}, IReduce {:line 217, :file nil, :protocol-symbol true, :name cljs.core/IReduce}, count {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/count, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :line 765, :fn-var true, :file nil}, set {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/set, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a set of the distinct elements of coll.", :line 5773, :fn-var true, :file nil}, -chunked-rest {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-rest, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 302, :fn-var true, :file nil}, extend-object! {:arglists (quote ([obj fn-map])), :method-params ([{:name obj, :tag nil, :shadow nil} {:name fn-map, :tag nil, :shadow nil}]), :name cljs.core/extend-object!, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implict this (via the this-as macro) will resolve to the\n  object that the function is attached.", :line 1546, :fn-var true, :file nil}, -chunked-first {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/IChunkedSeq, :name cljs.core/-chunked-first, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 302, :fn-var true, :file nil}, fn->comparator {:arglists (quote ([f])), :method-params ([{:name f, :tag nil, :shadow nil}]), :name cljs.core/fn->comparator, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator.", :line 1109, :fn-var true, :file nil}, comp {:arglists (quote ([] [f] [f g] [f g h] [f1 f2 f3 & fs])), :method-params ([] [{:name f, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil}] [{:name f1, :tag nil, :shadow nil} {:name f2, :tag nil, :shadow nil} {:name f3, :tag nil, :shadow nil} {:name fs, :tag nil, :shadow nil}]), :name cljs.core/comp, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic true, :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :line 2239, :fn-var true, :file nil}, nth {:arglists (quote ([coll n] [coll n not-found])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}] [{:name coll, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil} {:name not-found, :tag nil, :shadow nil}]), :name cljs.core/nth, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :line 793, :fn-var true, :file nil}, dissoc! {:arglists (quote ([tcoll key])), :method-params ([{:name tcoll, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil}]), :name cljs.core/dissoc!, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 2103, :fn-var true, :file nil}, -peek {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/IStack, :name cljs.core/-peek, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 198, :fn-var true, :file nil}, -assoc {:arglists (quote ([coll k v])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name v, :tag nil, :shadow nil}]), :protocol cljs.core/IAssociative, :name cljs.core/-assoc, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 182, :fn-var true, :file nil}, never-equiv {:line 3519, :file nil, :private true, :name cljs.core/never-equiv}, dominates {:arglists (quote ([x y prefer-table])), :method-params ([{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name prefer-table, :tag nil, :shadow nil}]), :name cljs.core/dominates, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 7055, :fn-var true, :file nil}, -prefer-method {:arglists (quote ([mf dispatch-val dispatch-val-y])), :method-params ([{:name mf, :tag nil, :shadow nil} {:name dispatch-val, :tag nil, :shadow nil} {:name dispatch-val-y, :tag nil, :shadow nil}]), :protocol cljs.core/IMultiFn, :name cljs.core/-prefer-method, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 7084, :fn-var true, :file nil}, ISorted {:line 244, :file nil, :protocol-symbol true, :name cljs.core/ISorted}, constantly {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/constantly, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a function that takes any number of arguments and returns x.", :line 2235, :fn-var true, :file nil}, ITransientMap {:line 286, :file nil, :protocol-symbol true, :name cljs.core/ITransientMap}, namespace {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/namespace, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :line 5836, :fn-var true, :file nil}, pr-str {:arglists (quote ([& objs])), :method-params ([{:name objs, :tag nil, :shadow nil}]), :name cljs.core/pr-str, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "pr to a string, returning it. Fundamental entrypoint to IPrintable.", :line 6301, :fn-var true, :file nil}, < {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/<, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :line 1233, :fn-var true, :file nil, :tag boolean}, sort-by {:arglists (quote ([keyfn coll] [keyfn comp coll])), :method-params ([{:name keyfn, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}] [{:name keyfn, :tag nil, :shadow nil} {:name comp, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/sort-by, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :line 1139, :fn-var true, :file nil}, cycle {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/cycle, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :line 2526, :fn-var true, :file nil}, peek {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/peek, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :line 854, :fn-var true, :file nil}, pr-with-opts {:arglists (quote ([objs opts])), :method-params ([{:name objs, :tag nil, :shadow nil} {:name opts, :tag nil, :shadow nil}]), :name cljs.core/pr-with-opts, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts", :line 6279, :fn-var true, :file nil}, reduce {:arglists (quote ([f coll] [f val coll])), :method-params ([{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/reduce, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :line 1173, :fn-var true, :file nil}, interleave {:arglists (quote ([c1 c2] [c1 c2 & colls])), :method-params ([{:name c1, :tag nil, :shadow nil} {:name c2, :tag nil, :shadow nil}] [{:name c1, :tag nil, :shadow nil} {:name c2, :tag nil, :shadow nil} {:name colls, :tag nil, :shadow nil}]), :name cljs.core/interleave, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :line 2558, :fn-var true, :file nil}, -sorted-seq {:arglists (quote ([coll ascending?])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name ascending?, :tag nil, :shadow nil}]), :protocol cljs.core/ISorted, :name cljs.core/-sorted-seq, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 244, :fn-var true, :file nil}, pv-aget {:arglists (quote ([node idx])), :method-params ([{:name node, :tag nil, :shadow nil} {:name idx, :tag nil, :shadow nil}]), :name cljs.core/pv-aget, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 2842, :fn-var true, :file nil}, cons {:arglists (quote ([x coll])), :method-params ([{:name x, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/cons, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a new seq where x is the first element and seq is the rest.", :line 1712, :fn-var true, :file nil}, str {:arglists (quote ([] [x] [x & ys])), :method-params ([] [{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name ys, :tag nil, :shadow nil}]), :name cljs.core/str, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic true, :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :line 1448, :fn-var true, :file nil}, ArrayNode {:protocols #{cljs.core/Object}, :num-fields 3, :type true, :line 4287, :file nil, :declared true, :name cljs.core/ArrayNode}, -rseq {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/IReversible, :name cljs.core/-rseq, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 241, :fn-var true, :file nil}, remove-all-methods {:arglists (quote ([multifn])), :method-params ([{:name multifn, :tag nil, :shadow nil}]), :name cljs.core/remove-all-methods, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Removes all of the methods of multimethod.", :line 7161, :fn-var true, :file nil}, ISeqable {:line 229, :file nil, :protocol-symbol true, :name cljs.core/ISeqable}, first {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/first, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :line 321, :fn-var true, :file nil}, PersistentHashSet {:line 5589, :file nil, :protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/IEditableCollection cljs.core/ISeqable cljs.core/ISet cljs.core/Object cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 3, :type true, :name cljs.core/PersistentHashSet}, = {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/=, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :line 354, :fn-var true, :file nil, :tag boolean}, array-reduce {:arglists (quote ([arr f] [arr f val] [arr f val idx])), :method-params ([{:name arr, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil}] [{:name arr, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}] [{:name arr, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil} {:name idx, :tag nil, :shadow nil}]), :name cljs.core/array-reduce, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :line 518, :fn-var true, :file nil}, memoize {:arglists (quote ([f])), :method-params ([{:name f, :tag nil, :shadow nil}]), :name cljs.core/memoize, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", :line 6866, :fn-var true, :file nil}, -remove-method {:arglists (quote ([mf dispatch-val])), :method-params ([{:name mf, :tag nil, :shadow nil} {:name dispatch-val, :tag nil, :shadow nil}]), :protocol cljs.core/IMultiFn, :name cljs.core/-remove-method, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 7084, :fn-var true, :file nil}, PersistentVector {:line 2922, :file nil, :protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IVector cljs.core/IHash cljs.core/IIndexed cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/IKVReduce cljs.core/IEditableCollection cljs.core/IAssociative cljs.core/ISeqable cljs.core/Object cljs.core/IMapEntry cljs.core/IReversible cljs.core/ISequential cljs.core/IReduce cljs.core/IStack cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 6, :type true, :name cljs.core/PersistentVector}, range {:arglists (quote ([] [end] [start end] [start end step])), :method-params ([] [{:name end, :tag nil, :shadow nil}] [{:name start, :tag nil, :shadow nil} {:name end, :tag nil, :shadow nil}] [{:name start, :tag nil, :shadow nil} {:name end, :tag nil, :shadow nil} {:name step, :tag nil, :shadow nil}]), :name cljs.core/range, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :line 5997, :fn-var true, :file nil}, tree-seq {:arglists (quote ([branch? children root])), :method-params ([{:name branch?, :tag nil, :shadow nil} {:name children, :tag nil, :shadow nil} {:name root, :tag nil, :shadow nil}]), :name cljs.core/tree-seq, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", :line 2623, :fn-var true, :file nil}, set-validator! {:arglists (quote ([iref val])), :method-params ([{:name iref, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}]), :name cljs.core/set-validator!, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :line 6738, :fn-var true, :file nil}, -lookup {:arglists (quote ([o k] [o k not-found])), :method-params ([{:name o, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil}] [{:name o, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name not-found, :tag nil, :shadow nil}]), :protocol cljs.core/ILookup, :name cljs.core/-lookup, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 179, :fn-var true, :file nil}, prefer-method {:arglists (quote ([multifn dispatch-val-x dispatch-val-y])), :method-params ([{:name multifn, :tag nil, :shadow nil} {:name dispatch-val-x, :tag nil, :shadow nil} {:name dispatch-val-y, :tag nil, :shadow nil}]), :name cljs.core/prefer-method, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict", :line 7171, :fn-var true, :file nil}, partition-all {:arglists (quote ([n coll] [n step coll])), :method-params ([{:name n, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}] [{:name n, :tag nil, :shadow nil} {:name step, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/partition-all, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.", :line 5871, :fn-var true, :file nil}, write-all {:arglists (quote ([writer & ss])), :method-params ([{:name writer, :tag nil, :shadow nil} {:name ss, :tag nil, :shadow nil}]), :name cljs.core/write-all, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic true, :line 6176, :fn-var true, :file nil}, reduced {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/reduced, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Wraps x in a way such that a reduce will terminate with the value x", :line 475, :fn-var true, :file nil}, not-every? {:arglists (quote ([pred coll])), :method-params ([{:name pred, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/not-every?, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :line 2194, :fn-var true, :file nil, :tag boolean}, ITransientVector {:line 289, :file nil, :protocol-symbol true, :name cljs.core/ITransientVector}, > {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/>, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :line 1257, :fn-var true, :file nil, :tag boolean}, max {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/max, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns the greatest of the nums.", :line 1285, :fn-var true, :file nil}, create-node {:arglists (quote ([shift key1 val1 key2hash key2 val2] [edit shift key1 val1 key2hash key2 val2])), :method-params ([{:name shift, :tag nil, :shadow nil} {:name key1, :tag nil, :shadow nil} {:name val1, :tag nil, :shadow nil} {:name key2hash, :tag nil, :shadow nil} {:name key2, :tag nil, :shadow nil} {:name val2, :tag nil, :shadow nil}] [{:name edit, :tag nil, :shadow nil} {:name shift, :tag nil, :shadow nil} {:name key1, :tag nil, :shadow nil} {:name val1, :tag nil, :shadow nil} {:name key2hash, :tag nil, :shadow nil} {:name key2, :tag nil, :shadow nil} {:name val2, :tag nil, :shadow nil}]), :name cljs.core/create-node, :protocol-impl nil, :max-fixed-arity 7, :private true, :protocol-inline nil, :variadic false, :line 4490, :fn-var true, :file nil}, identity {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/identity, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 2223, :fn-var true, :file nil}, fnext {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/fnext, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Same as (first (next x))", :line 721, :fn-var true, :file nil}, min-key {:arglists (quote ([k x] [k x y] [k x y & more])), :method-params ([{:name k, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil}] [{:name k, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name k, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/min-key, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic true, :doc "Returns the x for which (k x), a number, is least.", :line 5864, :fn-var true, :file nil}, List {:line 1558, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IList cljs.core/Object cljs.core/ASeq cljs.core/ISequential cljs.core/INext cljs.core/IStack cljs.core/IWithMeta cljs.core/ISeq}, :num-fields 5, :type true, :name cljs.core/List}, reset-meta! {:arglists (quote ([iref m])), :method-params ([{:name iref, :tag nil, :shadow nil} {:name m, :tag nil, :shadow nil}]), :name cljs.core/reset-meta!, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Atomically resets the metadata for an atom", :line 6762, :fn-var true, :file nil}, array {:arglists (quote ([var-args])), :method-params ([{:name var-args, :tag nil, :shadow nil}]), :name cljs.core/array, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Creates a new javascript array.\n@param {...*} var_args", :line 90, :fn-var true, :file nil}, *unchecked-if* {:line 16, :file nil, :name cljs.core/*unchecked-if*}, subs {:arglists (quote ([s start] [s start end])), :method-params ([{:name s, :tag nil, :shadow nil} {:name start, :tag nil, :shadow nil}] [{:name s, :tag nil, :shadow nil} {:name start, :tag nil, :shadow nil} {:name end, :tag nil, :shadow nil}]), :name cljs.core/subs, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :line 1465, :fn-var true, :file nil}, IPrintable {:line 250, :file nil, :deprecated true, :protocol-symbol true, :name cljs.core/IPrintable}, ISet {:line 195, :file nil, :protocol-symbol true, :name cljs.core/ISet}, printf {:arglists (quote ([fmt & args])), :method-params ([{:name fmt, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}]), :name cljs.core/printf, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic true, :doc "Prints formatted output, as per format", :line 6348, :fn-var true, :file nil}, -drop-first {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/IChunk, :name cljs.core/-drop-first, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 299, :fn-var true, :file nil}, ICounted {:line 155, :file nil, :protocol-symbol true, :name cljs.core/ICounted}, -methods {:arglists (quote ([mf])), :method-params ([{:name mf, :tag nil, :shadow nil}]), :protocol cljs.core/IMultiFn, :name cljs.core/-methods, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 7084, :fn-var true, :file nil}, ITransientCollection {:line 279, :file nil, :protocol-symbol true, :name cljs.core/ITransientCollection}, -invoke {:arglists (quote ([this] [this a] [this a b] [this a b c] [this a b c d] [this a b c d e] [this a b c d e f] [this a b c d e f g] [this a b c d e f g h] [this a b c d e f g h i] [this a b c d e f g h i j] [this a b c d e f g h i j k] [this a b c d e f g h i j k l] [this a b c d e f g h i j k l m] [this a b c d e f g h i j k l m n] [this a b c d e f g h i j k l m n o] [this a b c d e f g h i j k l m n o p] [this a b c d e f g h i j k l m n o p q] [this a b c d e f g h i j k l m n o p q s] [this a b c d e f g h i j k l m n o p q s t] [this a b c d e f g h i j k l m n o p q s t rest])), :method-params ([{:name this, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name l, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name l, :tag nil, :shadow nil} {:name m, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name l, :tag nil, :shadow nil} {:name m, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name l, :tag nil, :shadow nil} {:name m, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil} {:name o, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name l, :tag nil, :shadow nil} {:name m, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil} {:name o, :tag nil, :shadow nil} {:name p, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name l, :tag nil, :shadow nil} {:name m, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil} {:name o, :tag nil, :shadow nil} {:name p, :tag nil, :shadow nil} {:name q, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name l, :tag nil, :shadow nil} {:name m, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil} {:name o, :tag nil, :shadow nil} {:name p, :tag nil, :shadow nil} {:name q, :tag nil, :shadow nil} {:name s, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name l, :tag nil, :shadow nil} {:name m, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil} {:name o, :tag nil, :shadow nil} {:name p, :tag nil, :shadow nil} {:name q, :tag nil, :shadow nil} {:name s, :tag nil, :shadow nil} {:name t, :tag nil, :shadow nil}] [{:name this, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name e, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name l, :tag nil, :shadow nil} {:name m, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil} {:name o, :tag nil, :shadow nil} {:name p, :tag nil, :shadow nil} {:name q, :tag nil, :shadow nil} {:name s, :tag nil, :shadow nil} {:name t, :tag nil, :shadow nil} {:name rest, :tag nil, :shadow nil}]), :protocol cljs.core/IFn, :name cljs.core/-invoke, :protocol-impl nil, :max-fixed-arity 21, :protocol-inline nil, :variadic false, :line 131, :fn-var true, :file nil}, -deref {:arglists (quote ([o])), :method-params ([{:name o, :tag nil, :shadow nil}]), :protocol cljs.core/IDeref, :name cljs.core/-deref, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 205, :fn-var true, :file nil}, *print-fn* {:method-params ([{:name _, :tag nil, :shadow nil}]), :name cljs.core/*print-fn*, :protocol-impl nil, :max-fixed-arity 1, :dynamic true, :protocol-inline nil, :variadic false, :doc "Each runtime environment provides a diffenent way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :line 18, :fn-var true, :file nil}, IStack {:line 198, :file nil, :protocol-symbol true, :name cljs.core/IStack}, >= {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/>=, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :line 1269, :fn-var true, :file nil, :tag boolean}, hash-imap {:arglists (quote ([m])), :method-params ([{:name m, :tag nil, :shadow nil}]), :name cljs.core/hash-imap, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 1525, :fn-var true, :file nil}, reduce-kv {:arglists (quote ([f init coll])), :method-params ([{:name f, :tag nil, :shadow nil} {:name init, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/reduce-kv, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :line 1192, :fn-var true, :file nil}, reset! {:arglists (quote ([a new-value])), :method-params ([{:name a, :tag nil, :shadow nil} {:name new-value, :tag nil, :shadow nil}]), :name cljs.core/reset!, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Sets the value of atom to newval without regard for the\n  current value. Returns newval.", :line 6695, :fn-var true, :file nil}, even? {:arglists (quote ([n])), :method-params ([{:name n, :tag nil, :shadow nil}]), :name cljs.core/even?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if n is even, throws an exception if n is not an integer", :line 2213, :fn-var true, :file nil, :tag boolean}, bit-shift-left {:arglists (quote ([x n])), :method-params ([{:name x, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}]), :name cljs.core/bit-shift-left, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Bitwise shift left", :line 1380, :fn-var true, :file nil}, new-path {:arglists (quote ([edit level node])), :method-params ([{:name edit, :tag nil, :shadow nil} {:name level, :tag nil, :shadow nil} {:name node, :tag nil, :shadow nil}]), :name cljs.core/new-path, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 2857, :fn-var true, :file nil}, methods {:arglists (quote ([multifn])), :method-params ([{:name multifn, :tag nil, :shadow nil}]), :name cljs.core/methods, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns", :line 7177, :fn-var true, :file nil}, balance-left {:arglists (quote ([key val ins right])), :method-params ([{:name key, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil} {:name ins, :tag nil, :shadow nil} {:name right, :tag nil, :shadow nil}]), :name cljs.core/balance-left, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :line 4894, :fn-var true, :file nil}, compare {:arglists (quote ([x y])), :method-params ([{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}]), :name cljs.core/compare, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :line 1079, :fn-var true, :file nil}, IMultiFn {:line 7084, :file nil, :protocol-symbol true, :name cljs.core/IMultiFn}, string-hash-cache {:line 880, :file nil, :name cljs.core/string-hash-cache}, PersistentQueueSeq {:line 3428, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ISeqable cljs.core/Object cljs.core/ISequential cljs.core/IWithMeta cljs.core/ISeq}, :num-fields 4, :type true, :name cljs.core/PersistentQueueSeq}, sorted-set-by {:arglists (quote ([comparator & keys])), :method-params ([{:name comparator, :tag nil, :shadow nil} {:name keys, :tag nil, :shadow nil}]), :name cljs.core/sorted-set-by, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic true, :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :line 5783, :fn-var true, :file nil}, -assoc-n! {:arglists (quote ([tcoll n val])), :method-params ([{:name tcoll, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}]), :protocol cljs.core/ITransientVector, :name cljs.core/-assoc-n!, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 289, :fn-var true, :file nil}, -meta {:arglists (quote ([o])), :method-params ([{:name o, :tag nil, :shadow nil}]), :protocol cljs.core/IMeta, :name cljs.core/-meta, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 211, :fn-var true, :file nil}, group-by {:arglists (quote ([f coll])), :method-params ([{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/group-by, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", :line 6913, :fn-var true, :file nil}, bitmap-indexed-node-index {:arglists (quote ([bitmap bit])), :method-params ([{:name bitmap, :tag nil, :shadow nil} {:name bit, :tag nil, :shadow nil}]), :name cljs.core/bitmap-indexed-node-index, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 4041, :fn-var true, :file nil}, EmptyList {:line 1608, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IList cljs.core/Object cljs.core/ISequential cljs.core/INext cljs.core/IStack cljs.core/IWithMeta cljs.core/ISeq}, :num-fields 1, :type true, :name cljs.core/EmptyList}, get {:arglists (quote ([o k] [o k not-found])), :method-params ([{:name o, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil}] [{:name o, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name not-found, :tag nil, :shadow nil}]), :name cljs.core/get, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Returns the value mapped to key, not-found or nil if key not present.", :line 810, :fn-var true, :file nil}, <= {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/<=, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :line 1245, :fn-var true, :file nil, :tag boolean}, -pr-seq {:arglists (quote ([o opts])), :method-params ([{:name o, :tag nil, :shadow nil} {:name opts, :tag nil, :shadow nil}]), :protocol cljs.core/IPrintable, :name cljs.core/-pr-seq, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 250, :fn-var true, :file nil}, mask {:arglists (quote ([hash shift])), :method-params ([{:name hash, :tag nil, :shadow nil} {:name shift, :tag nil, :shadow nil}]), :name cljs.core/mask, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 4023, :fn-var true, :file nil}, tree-map-add {:arglists (quote ([comp tree k v found])), :method-params ([{:name comp, :tag nil, :shadow nil} {:name tree, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name v, :tag nil, :shadow nil} {:name found, :tag nil, :shadow nil}]), :name cljs.core/tree-map-add, :protocol-impl nil, :max-fixed-arity 5, :private true, :protocol-inline nil, :variadic false, :line 5250, :fn-var true, :file nil}, -rest {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/ISeq, :name cljs.core/-rest, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 172, :fn-var true, :file nil}, regexp? {:arglists (quote ([o])), :method-params ([{:name o, :tag nil, :shadow nil}]), :name cljs.core/regexp?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 6117, :fn-var true, :file nil}, -chunked-next {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/IChunkedNext, :name cljs.core/-chunked-next, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 306, :fn-var true, :file nil}, fnil {:arglists (quote ([f x] [f x y] [f x y z])), :method-params ([{:name f, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name z, :tag nil, :shadow nil}]), :name cljs.core/fnil, :protocol-impl nil, :max-fixed-arity 4, :protocol-inline nil, :variadic false, :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :line 2281, :fn-var true, :file nil}, string-hash-cache-count {:line 881, :file nil, :name cljs.core/string-hash-cache-count}, force {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/force, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", :line 6835, :fn-var true, :file nil}, create-inode-seq {:arglists (quote ([nodes] [nodes i s])), :method-params ([{:name nodes, :tag nil, :shadow nil}] [{:name nodes, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name s, :tag nil, :shadow nil}]), :name cljs.core/create-inode-seq, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 4552, :fn-var true, :file nil}, partial {:arglists (quote ([f arg1] [f arg1 arg2] [f arg1 arg2 arg3] [f arg1 arg2 arg3 & more])), :method-params ([{:name f, :tag nil, :shadow nil} {:name arg1, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name arg1, :tag nil, :shadow nil} {:name arg2, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name arg1, :tag nil, :shadow nil} {:name arg2, :tag nil, :shadow nil} {:name arg3, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name arg1, :tag nil, :shadow nil} {:name arg2, :tag nil, :shadow nil} {:name arg3, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/partial, :protocol-impl nil, :max-fixed-arity 4, :protocol-inline nil, :variadic true, :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :line 2268, :fn-var true, :file nil}, -disjoin {:arglists (quote ([coll v])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name v, :tag nil, :shadow nil}]), :protocol cljs.core/ISet, :name cljs.core/-disjoin, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 195, :fn-var true, :file nil}, BlackNode {:protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IVector cljs.core/IHash cljs.core/IIndexed cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/IAssociative cljs.core/ISeqable cljs.core/Object cljs.core/IMapEntry cljs.core/ISequential cljs.core/IReduce cljs.core/IStack cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 5, :type true, :line 4995, :file nil, :declared true, :name cljs.core/BlackNode}, -conj! {:arglists (quote ([tcoll val])), :method-params ([{:name tcoll, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}]), :protocol cljs.core/ITransientCollection, :name cljs.core/-conj!, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 279, :fn-var true, :file nil}, array-seq {:arglists (quote ([array] [array i])), :method-params ([{:name array, :tag nil, :shadow nil}] [{:name array, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil}]), :name cljs.core/array-seq, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 630, :fn-var true, :file nil}, pos? {:arglists (quote ([n])), :method-params ([{:name n, :tag nil, :shadow nil}]), :name cljs.core/pos?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if num is greater than zero, else false", :line 1412, :fn-var true, :file nil, :tag boolean}, ISeq {:line 172, :file nil, :protocol-symbol true, :name cljs.core/ISeq}, take-while {:arglists (quote ([pred coll])), :method-params ([{:name pred, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/take-while, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns true. pred must be free of side-effects.", :line 5881, :fn-var true, :file nil}, balance-right {:arglists (quote ([key val left ins])), :method-params ([{:name key, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil} {:name left, :tag nil, :shadow nil} {:name ins, :tag nil, :shadow nil}]), :name cljs.core/balance-right, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :line 4919, :fn-var true, :file nil}, IVector {:line 202, :file nil, :protocol-symbol true, :name cljs.core/IVector}, IChunkedNext {:line 306, :file nil, :protocol-symbol true, :name cljs.core/IChunkedNext}, underive {:arglists (quote ([tag parent] [h tag parent])), :method-params ([{:name tag, :tag nil, :shadow nil} {:name parent, :tag nil, :shadow nil}] [{:name h, :tag nil, :shadow nil} {:name tag, :tag nil, :shadow nil} {:name parent, :tag nil, :shadow nil}]), :name cljs.core/underive, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :line 7011, :fn-var true, :file nil}, ancestors {:arglists (quote ([tag] [h tag])), :method-params ([{:name tag, :tag nil, :shadow nil}] [{:name h, :tag nil, :shadow nil} {:name tag, :tag nil, :shadow nil}]), :name cljs.core/ancestors, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :line 6960, :fn-var true, :file nil}, hash-combine {:arglists (quote ([seed hash])), :method-params ([{:name seed, :tag nil, :shadow nil} {:name hash, :tag nil, :shadow nil}]), :name cljs.core/hash-combine, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 1514, :fn-var true, :file nil}, IEquiv {:line 223, :file nil, :protocol-symbol true, :name cljs.core/IEquiv}, persistent! {:arglists (quote ([tcoll])), :method-params ([{:name tcoll, :tag nil, :shadow nil}]), :name cljs.core/persistent!, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 2094, :fn-var true, :file nil}, partition {:arglists (quote ([n coll] [n step coll] [n step pad coll])), :method-params ([{:name n, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}] [{:name n, :tag nil, :shadow nil} {:name step, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}] [{:name n, :tag nil, :shadow nil} {:name step, :tag nil, :shadow nil} {:name pad, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/partition, :protocol-impl nil, :max-fixed-arity 4, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :line 2679, :fn-var true, :file nil}, lazy-seq-value {:arglists (quote ([lazy-seq])), :method-params ([{:name lazy-seq, :tag nil, :shadow nil}]), :name cljs.core/lazy-seq-value, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 1787, :fn-var true, :file nil}, map-indexed {:arglists (quote ([f coll])), :method-params ([{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/map-indexed, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item.", :line 2304, :fn-var true, :file nil}, ChunkBuffer {:line 1832, :file nil, :protocols #{cljs.core/ICounted cljs.core/Object}, :num-fields 2, :type true, :name cljs.core/ChunkBuffer}, contains? {:arglists (quote ([coll v])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name v, :tag nil, :shadow nil}]), :name cljs.core/contains?, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :line 1042, :fn-var true, :file nil, :tag boolean}, interpose {:arglists (quote ([sep coll])), :method-params ([{:name sep, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/interpose, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy seq of the elements of coll separated by sep", :line 2572, :fn-var true, :file nil}, chunk {:arglists (quote ([b])), :method-params ([{:name b, :tag nil, :shadow nil}]), :name cljs.core/chunk, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1937, :fn-var true, :file nil}, ifn? {:arglists (quote ([f])), :method-params ([{:name f, :tag nil, :shadow nil}]), :name cljs.core/ifn?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1031, :fn-var true, :file nil, :tag boolean}, remove-pair {:arglists (quote ([arr i])), :method-params ([{:name arr, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil}]), :name cljs.core/remove-pair, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 4035, :fn-var true, :file nil}, IWithMeta {:line 214, :file nil, :protocol-symbol true, :name cljs.core/IWithMeta}, obj-map->hash-map {:arglists (quote ([m k v])), :method-params ([{:name m, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name v, :tag nil, :shadow nil}]), :name cljs.core/obj-map->hash-map, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 3557, :fn-var true, :file nil}, IMeta {:line 211, :file nil, :protocol-symbol true, :name cljs.core/IMeta}, apply {:arglists (quote ([f args] [f x args] [f x y args] [f x y z args] [f a b c d & args])), :method-params ([{:name f, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name z, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name a, :tag nil, :shadow nil} {:name b, :tag nil, :shadow nil} {:name c, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}]), :name cljs.core/apply, :protocol-impl nil, :max-fixed-arity 5, :protocol-inline nil, :variadic true, :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.\n  First cut.  Not lazy.  Needs to use emitted toApply.", :line 2119, :fn-var true, :file nil}, swap! {:arglists (quote ([a f] [a f x] [a f x y] [a f x y z] [a f x y z & more])), :method-params ([{:name a, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil}] [{:name a, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil}] [{:name a, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name a, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name z, :tag nil, :shadow nil}] [{:name a, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name z, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/swap!, :protocol-impl nil, :max-fixed-arity 5, :protocol-inline nil, :variadic true, :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :line 6706, :fn-var true, :file nil}, truth_ {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/truth_, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Internal - do not use!", :line 38, :fn-var true, :file nil}, array-copy {:arglists (quote ([from i to j len])), :method-params ([{:name from, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name to, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name len, :tag nil, :shadow nil}]), :name cljs.core/array-copy, :protocol-impl nil, :max-fixed-arity 5, :private true, :protocol-inline nil, :variadic false, :line 966, :fn-var true, :file nil}, subvec {:arglists (quote ([v start] [v start end])), :method-params ([{:name v, :tag nil, :shadow nil} {:name start, :tag nil, :shadow nil}] [{:name v, :tag nil, :shadow nil} {:name start, :tag nil, :shadow nil} {:name end, :tag nil, :shadow nil}]), :name cljs.core/subvec, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :line 3232, :fn-var true, :file nil}, rest {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/rest, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :line 332, :fn-var true, :file nil, :tag seq}, -val {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/IMapEntry, :name cljs.core/-val, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 191, :fn-var true, :file nil}, keyword {:arglists (quote ([name] [ns name])), :method-params ([{:name name, :tag nil, :shadow nil}] [{:name ns, :tag nil, :shadow nil} {:name name, :tag nil, :shadow nil}]), :name cljs.core/keyword, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :line 1492, :fn-var true, :file nil}, -assoc-n {:arglists (quote ([coll n val])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}]), :protocol cljs.core/IVector, :name cljs.core/-assoc-n, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 202, :fn-var true, :file nil}, IComparable {:line 296, :file nil, :protocol-symbol true, :name cljs.core/IComparable}, indexed? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/indexed?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if coll implements nth in constant time", :line 555, :fn-var true, :file nil, :tag boolean}, int {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/int, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Coerce to int by stripping decimal places.", :line 1304, :fn-var true, :file nil}, quote-string {:arglists (quote ([s])), :method-params ([{:name s, :tag nil, :shadow nil}]), :name cljs.core/quote-string, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 6361, :fn-var true, :file nil}, mod {:arglists (quote ([n d])), :method-params ([{:name n, :tag nil, :shadow nil} {:name d, :tag nil, :shadow nil}]), :name cljs.core/mod, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Modulus of num and div. Truncates toward negative infinity.", :line 1314, :fn-var true, :file nil}, nfirst {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/nfirst, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Same as (next (first x))", :line 716, :fn-var true, :file nil}, nthnext {:arglists (quote ([coll n])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}]), :name cljs.core/nthnext, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns the nth next of coll, (seq coll) when n is 0.", :line 1425, :fn-var true, :file nil}, pv-fresh-node {:arglists (quote ([edit])), :method-params ([{:name edit, :tag nil, :shadow nil}]), :name cljs.core/pv-fresh-node, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 2839, :fn-var true, :file nil}, tree-map-seq-push {:arglists (quote ([node stack ascending?])), :method-params ([{:name node, :tag nil, :shadow nil} {:name stack, :tag nil, :shadow nil} {:name ascending?, :tag boolean, :shadow nil}]), :name cljs.core/tree-map-seq-push, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 4837, :fn-var true, :file nil}, array-for {:arglists (quote ([pv i])), :method-params ([{:name pv, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil}]), :name cljs.core/array-for, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 2883, :fn-var true, :file nil}, array-map {:arglists (quote ([& keyvals])), :method-params ([{:name keyvals, :tag nil, :shadow nil}]), :name cljs.core/array-map, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :line 5489, :fn-var true, :file nil}, -count {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/ICounted, :name cljs.core/-count, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 155, :fn-var true, :file nil}, IIndexed {:line 167, :file nil, :protocol-symbol true, :name cljs.core/IIndexed}, tree-map-kv-reduce {:arglists (quote ([node f init])), :method-params ([{:name node, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name init, :tag nil, :shadow nil}]), :name cljs.core/tree-map-kv-reduce, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :line 4979, :fn-var true, :file nil}, dec {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/dec, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a number one less than num.", :line 1281, :fn-var true, :file nil}, undefined? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/undefined?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 994, :fn-var true, :file nil, :tag boolean}, println {:arglists (quote ([& objs])), :method-params ([{:name objs, :tag nil, :shadow nil}]), :name cljs.core/println, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "Same as print followed by (newline)", :line 6331, :fn-var true, :file nil}, array-copy-downward {:arglists (quote ([from i to j len])), :method-params ([{:name from, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name to, :tag nil, :shadow nil} {:name j, :tag nil, :shadow nil} {:name len, :tag nil, :shadow nil}]), :name cljs.core/array-copy-downward, :protocol-impl nil, :max-fixed-arity 5, :private true, :protocol-inline nil, :variadic false, :line 974, :fn-var true, :file nil}, aget {:arglists (quote ([array i] [array i & idxs])), :method-params ([{:name array, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil}] [{:name array, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name idxs, :tag nil, :shadow nil}]), :name cljs.core/aget, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns the value at the index.", :line 104, :fn-var true, :file nil}, pr {:arglists (quote ([& objs])), :method-params ([{:name objs, :tag nil, :shadow nil}]), :name cljs.core/pr, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :line 6311, :fn-var true, :file nil}, drop {:arglists (quote ([n coll])), :method-params ([{:name n, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/drop, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of all but the first n items in coll.", :line 2491, :fn-var true, :file nil}, -conj {:arglists (quote ([coll o])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name o, :tag nil, :shadow nil}]), :protocol cljs.core/ICollection, :name cljs.core/-conj, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 161, :fn-var true, :file nil}, *print-dup* {:line 6293, :file nil, :name cljs.core/*print-dup*}, IWriter {:line 256, :file nil, :protocol-symbol true, :name cljs.core/IWriter}, IEmptyableCollection {:line 158, :file nil, :protocol-symbol true, :name cljs.core/IEmptyableCollection}, aclone {:arglists (quote ([array-like])), :method-params ([{:name array-like, :tag nil, :shadow nil}]), :name cljs.core/aclone, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns a javascript array, cloned from the passed in array", :line 85, :fn-var true, :file nil}, UUID {:line 7192, :file nil, :protocols #{cljs.core/IEquiv cljs.core/IHash cljs.core/Object cljs.core/IPrintWithWriter cljs.core/IPrintable}, :num-fields 1, :type true, :name cljs.core/UUID}, pop {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/pop, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :line 860, :fn-var true, :file nil}, atom {:arglists (quote ([x] [x & {:keys [meta validator]}])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name p__3749, :tag nil, :shadow nil}]), :name cljs.core/atom, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic true, :doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will be come the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :line 6678, :fn-var true, :file nil}, bit-shift-right {:arglists (quote ([x n])), :method-params ([{:name x, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}]), :name cljs.core/bit-shift-right, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Bitwise shift right", :line 1384, :fn-var true, :file nil}, delay? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/delay?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "returns true if x is a Delay created with delay", :line 6831, :fn-var true, :file nil, :tag boolean}, Cons {:line 1675, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ISeqable cljs.core/IList cljs.core/Object cljs.core/ASeq cljs.core/ISequential cljs.core/INext cljs.core/IWithMeta cljs.core/ISeq}, :num-fields 4, :type true, :name cljs.core/Cons}, -dissoc! {:arglists (quote ([tcoll key])), :method-params ([{:name tcoll, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil}]), :protocol cljs.core/ITransientMap, :name cljs.core/-dissoc!, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 286, :fn-var true, :file nil}, realized? {:arglists (quote ([d])), :method-params ([{:name d, :tag nil, :shadow nil}]), :name cljs.core/realized?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", :line 6842, :fn-var true, :file nil, :tag boolean}, disj {:arglists (quote ([coll] [coll k] [coll k & ks])), :method-params ([{:name coll, :tag nil, :shadow nil}] [{:name coll, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil}] [{:name coll, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name ks, :tag nil, :shadow nil}]), :name cljs.core/disj, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :line 867, :fn-var true, :file nil}, *print-readably* {:line 6291, :file nil, :name cljs.core/*print-readably*}, merge-with {:arglists (quote ([f & maps])), :method-params ([{:name f, :tag nil, :shadow nil} {:name maps, :tag nil, :shadow nil}]), :name cljs.core/merge-with, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic true, :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :line 5555, :fn-var true, :file nil}, take-nth {:arglists (quote ([n coll])), :method-params ([{:name n, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/take-nth, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy seq of every nth item in coll.", :line 6006, :fn-var true, :file nil}, IChunkedSeq {:line 302, :file nil, :protocol-symbol true, :name cljs.core/IChunkedSeq}, *print-meta* {:line 6292, :file nil, :name cljs.core/*print-meta*}, -hash {:arglists (quote ([o])), :method-params ([{:name o, :tag nil, :shadow nil}]), :protocol cljs.core/IHash, :name cljs.core/-hash, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 226, :fn-var true, :file nil}, obj-map {:arglists (quote ([& keyvals])), :method-params ([{:name keyvals, :tag nil, :shadow nil}]), :name cljs.core/obj-map, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :line 5495, :fn-var true, :file nil}, take-last {:arglists (quote ([n coll])), :method-params ([{:name n, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/take-last, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :line 2506, :fn-var true, :file nil}, take {:arglists (quote ([n coll])), :method-params ([{:name n, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/take, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.", :line 2482, :fn-var true, :file nil}, -persistent! {:arglists (quote ([tcoll])), :method-params ([{:name tcoll, :tag nil, :shadow nil}]), :protocol cljs.core/ITransientCollection, :name cljs.core/-persistent!, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 279, :fn-var true, :file nil}, check-string-hash-cache {:arglists (quote ([k])), :method-params ([{:name k, :tag nil, :shadow nil}]), :name cljs.core/check-string-hash-cache, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 889, :fn-var true, :file nil}, apply-to {:arglists (quote ([f argc args])), :method-params ([{:name f, :tag nil, :shadow nil} {:name argc, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}]), :name cljs.core/apply-to, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 2116, :fn-var true, :file nil}, obj-clone {:arglists (quote ([obj ks])), :method-params ([{:name obj, :tag nil, :shadow nil} {:name ks, :tag nil, :shadow nil}]), :name cljs.core/obj-clone, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 3571, :fn-var true, :file nil}, IList {:line 235, :file nil, :protocol-symbol true, :name cljs.core/IList}, set? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/set?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if x satisfies ISet", :line 918, :fn-var true, :file nil, :tag boolean}, make-array {:arglists (quote ([size] [type size])), :method-params ([{:name size, :tag nil, :shadow nil}] [{:name type, :tag nil, :shadow nil} {:name size, :tag nil, :shadow nil}]), :name cljs.core/make-array, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 96, :fn-var true, :file nil}, rand-nth {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/rand-nth, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", :line 6906, :fn-var true, :file nil}, juxt {:arglists (quote ([f] [f g] [f g h] [f g h & fs])), :method-params ([{:name f, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name g, :tag nil, :shadow nil} {:name h, :tag nil, :shadow nil} {:name fs, :tag nil, :shadow nil}]), :name cljs.core/juxt, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic true, :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :line 6052, :fn-var true, :file nil}, alength {:arglists (quote ([array])), :method-params ([{:name array, :tag nil, :shadow nil}]), :name cljs.core/alength, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns the length of the array. Works on arrays of all types.", :line 116, :fn-var true, :file nil}, chunk-first {:arglists (quote ([s])), :method-params ([{:name s, :tag nil, :shadow nil}]), :name cljs.core/chunk-first, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1940, :fn-var true, :file nil}, tree-map-append {:arglists (quote ([left right])), :method-params ([{:name left, :tag nil, :shadow nil} {:name right, :tag nil, :shadow nil}]), :name cljs.core/tree-map-append, :protocol-impl nil, :max-fixed-arity 2, :private true, :protocol-inline nil, :variadic false, :line 5269, :fn-var true, :file nil}, to-array {:arglists (quote ([s])), :method-params ([{:name s, :tag nil, :shadow nil}]), :name cljs.core/to-array, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Naive impl of to-array as a start.", :line 1953, :fn-var true, :file nil}, hash-map {:arglists (quote ([& keyvals])), :method-params ([{:name keyvals, :tag nil, :shadow nil}]), :name cljs.core/hash-map, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :line 5480, :fn-var true, :file nil}, Range {:line 5926, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IIndexed cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/Object cljs.core/ISequential cljs.core/INext cljs.core/IReduce cljs.core/IWithMeta cljs.core/ISeq}, :num-fields 5, :type true, :name cljs.core/Range}, bit-and-not {:arglists (quote ([x y])), :method-params ([{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}]), :name cljs.core/bit-and-not, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Bitwise and", :line 1352, :fn-var true, :file nil}, compare-and-set! {:arglists (quote ([a oldval newval])), :method-params ([{:name a, :tag nil, :shadow nil} {:name oldval, :tag nil, :shadow nil} {:name newval, :tag nil, :shadow nil}]), :name cljs.core/compare-and-set!, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false.", :line 6722, :fn-var true, :file nil}, -pop! {:arglists (quote ([tcoll])), :method-params ([{:name tcoll, :tag nil, :shadow nil}]), :protocol cljs.core/ITransientVector, :name cljs.core/-pop!, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 289, :fn-var true, :file nil}, ITransientAssociative {:line 283, :file nil, :protocol-symbol true, :name cljs.core/ITransientAssociative}, type {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/type, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 368, :fn-var true, :file nil}, repeatedly {:arglists (quote ([f] [n f])), :method-params ([{:name f, :tag nil, :shadow nil}] [{:name n, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil}]), :name cljs.core/repeatedly, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :line 2546, :fn-var true, :file nil}, trampoline {:arglists (quote ([f] [f & args])), :method-params ([{:name f, :tag nil, :shadow nil}] [{:name f, :tag nil, :shadow nil} {:name args, :tag nil, :shadow nil}]), :name cljs.core/trampoline, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic true, :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :line 6880, :fn-var true, :file nil}, remove {:arglists (quote ([pred coll])), :method-params ([{:name pred, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/remove, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns false. pred must be free of side-effects.", :line 2617, :fn-var true, :file nil}, reset-cache {:arglists (quote ([method-cache method-table cached-hierarchy hierarchy])), :method-params ([{:name method-cache, :tag nil, :shadow nil} {:name method-table, :tag nil, :shadow nil} {:name cached-hierarchy, :tag nil, :shadow nil} {:name hierarchy, :tag nil, :shadow nil}]), :name cljs.core/reset-cache, :protocol-impl nil, :max-fixed-arity 4, :private true, :protocol-inline nil, :variadic false, :line 7032, :fn-var true, :file nil}, find {:arglists (quote ([coll k])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil}]), :name cljs.core/find, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns the map entry for key, or nil if key not present.", :line 1053, :fn-var true, :file nil}, do-assoc {:arglists (quote ([pv level node i val])), :method-params ([{:name pv, :tag nil, :shadow nil} {:name level, :tag nil, :shadow nil} {:name node, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}]), :name cljs.core/do-assoc, :protocol-impl nil, :max-fixed-arity 5, :private true, :protocol-inline nil, :variadic false, :line 2895, :fn-var true, :file nil}, coll? {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/coll?, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if x satisfies ICollection", :line 911, :fn-var true, :file nil, :tag boolean}, drop-while {:arglists (quote ([pred coll])), :method-params ([{:name pred, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/drop-while, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of the items in coll starting from the first\n  item for which (pred item) returns nil.", :line 2515, :fn-var true, :file nil}, not-empty {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :name cljs.core/not-empty, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "If coll is empty, returns nil, else coll", :line 2181, :fn-var true, :file nil}, flatten {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/flatten, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :line 2638, :fn-var true, :file nil}, pr-writer {:arglists (quote ([obj writer opts])), :method-params ([{:name obj, :tag nil, :shadow nil} {:name writer, :tag nil, :shadow nil} {:name opts, :tag nil, :shadow nil}]), :name cljs.core/pr-writer, :protocol-impl nil, :max-fixed-arity 3, :private true, :protocol-inline nil, :variadic false, :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer.", :line 6216, :fn-var true, :file nil}, -reduce {:arglists (quote ([coll f] [coll f start])), :method-params ([{:name coll, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil}] [{:name coll, :tag nil, :shadow nil} {:name f, :tag nil, :shadow nil} {:name start, :tag nil, :shadow nil}]), :protocol cljs.core/IReduce, :name cljs.core/-reduce, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic false, :line 217, :fn-var true, :file nil}, println-str {:arglists (quote ([& objs])), :method-params ([{:name objs, :tag nil, :shadow nil}]), :name cljs.core/println-str, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "println to a string, returning it", :line 6337, :fn-var true, :file nil}, ArrayNodeSeq {:line 4569, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ISeqable cljs.core/Object cljs.core/ISequential cljs.core/IWithMeta cljs.core/ISeq}, :num-fields 5, :type true, :name cljs.core/ArrayNodeSeq}, IMap {:line 187, :file nil, :protocol-symbol true, :name cljs.core/IMap}, list {:arglists (quote ([] [x] [x y] [x y z] [x y z & items])), :method-params ([] [{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name z, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name z, :tag nil, :shadow nil} {:name items, :tag nil, :shadow nil}]), :name cljs.core/list, :protocol-impl nil, :max-fixed-arity 3, :protocol-inline nil, :variadic true, :line 1666, :fn-var true, :file nil}, chunk-next {:arglists (quote ([s])), :method-params ([{:name s, :tag nil, :shadow nil}]), :name cljs.core/chunk-next, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 1946, :fn-var true, :file nil}, every? {:arglists (quote ([pred coll])), :method-params ([{:name pred, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/every?, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :line 2185, :fn-var true, :file nil, :tag boolean}, flush {:arglists (quote ([])), :method-params ([]), :name cljs.core/flush, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic false, :line 6184, :fn-var true, :file nil}, Reduced {:line 471, :file nil, :protocols #{cljs.core/IDeref}, :num-fields 1, :type true, :name cljs.core/Reduced}, sort {:arglists (quote ([coll] [comp coll])), :method-params ([{:name coll, :tag nil, :shadow nil}] [{:name comp, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/sort, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison funcion, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :line 1125, :fn-var true, :file nil}, -pop {:arglists (quote ([coll])), :method-params ([{:name coll, :tag nil, :shadow nil}]), :protocol cljs.core/IStack, :name cljs.core/-pop, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :line 198, :fn-var true, :file nil}, dissoc {:arglists (quote ([coll] [coll k] [coll k & ks])), :method-params ([{:name coll, :tag nil, :shadow nil}] [{:name coll, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil}] [{:name coll, :tag nil, :shadow nil} {:name k, :tag nil, :shadow nil} {:name ks, :tag nil, :shadow nil}]), :name cljs.core/dissoc, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :line 830, :fn-var true, :file nil}, not {:arglists (quote ([x])), :method-params ([{:name x, :tag nil, :shadow nil}]), :name cljs.core/not, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns true if x is logical false, false otherwise.", :line 53, :fn-var true, :file nil, :tag boolean}, IDerefWithTimeout {:line 208, :file nil, :protocol-symbol true, :name cljs.core/IDerefWithTimeout}, get-method {:arglists (quote ([multifn dispatch-val])), :method-params ([{:name multifn, :tag nil, :shadow nil} {:name dispatch-val, :tag nil, :shadow nil}]), :name cljs.core/get-method, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", :line 7181, :fn-var true, :file nil}, sorted-set {:arglists (quote ([& keys])), :method-params ([{:name keys, :tag nil, :shadow nil}]), :name cljs.core/sorted-set, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "Returns a new sorted set with supplied keys.", :line 5778, :fn-var true, :file nil}, merge {:arglists (quote ([& maps])), :method-params ([{:name maps, :tag nil, :shadow nil}]), :name cljs.core/merge, :protocol-impl nil, :max-fixed-arity 0, :protocol-inline nil, :variadic true, :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :line 5547, :fn-var true, :file nil}, subseq {:arglists (quote ([sc test key] [sc start-test start-key end-test end-key])), :method-params ([{:name sc, :tag nil, :shadow nil} {:name test, :tag nil, :shadow nil} {:name key, :tag nil, :shadow nil}] [{:name sc, :tag nil, :shadow nil} {:name start-test, :tag nil, :shadow nil} {:name start-key, :tag nil, :shadow nil} {:name end-test, :tag nil, :shadow nil} {:name end-key, :tag nil, :shadow nil}]), :name cljs.core/subseq, :protocol-impl nil, :max-fixed-arity 5, :protocol-inline nil, :variadic false, :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :line 5896, :fn-var true, :file nil}, ObjMap {:line 3581, :file nil, :protocols #{cljs.core/IMeta cljs.core/IFn cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/IEditableCollection cljs.core/IAssociative cljs.core/ISeqable cljs.core/Object cljs.core/IMap cljs.core/IWithMeta cljs.core/ILookup}, :num-fields 5, :type true, :name cljs.core/ObjMap}, missing-protocol {:arglists (quote ([proto obj])), :method-params ([{:name proto, :tag nil, :shadow nil} {:name obj, :tag nil, :shadow nil}]), :name cljs.core/missing-protocol, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 78, :fn-var true, :file nil}, min {:arglists (quote ([x] [x y] [x y & more])), :method-params ([{:name x, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil}] [{:name x, :tag nil, :shadow nil} {:name y, :tag nil, :shadow nil} {:name more, :tag nil, :shadow nil}]), :name cljs.core/min, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic true, :doc "Returns the least of the nums.", :line 1292, :fn-var true, :file nil}, bit-test {:arglists (quote ([x n])), :method-params ([{:name x, :tag nil, :shadow nil} {:name n, :tag nil, :shadow nil}]), :name cljs.core/bit-test, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Test bit at index n", :line 1375, :fn-var true, :file nil}, keep {:arglists (quote ([f coll])), :method-params ([{:name f, :tag nil, :shadow nil} {:name coll, :tag nil, :shadow nil}]), :name cljs.core/keep, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.", :line 2323, :fn-var true, :file nil}, disj! {:arglists (quote ([tcoll val])), :method-params ([{:name tcoll, :tag nil, :shadow nil} {:name val, :tag nil, :shadow nil}]), :name cljs.core/disj!, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 2109, :fn-var true, :file nil}, VectorNode {:line 2837, :file nil, :protocols #{}, :num-fields 2, :type true, :name cljs.core/VectorNode}, meta {:arglists (quote ([o])), :method-params ([{:name o, :tag nil, :shadow nil}]), :name cljs.core/meta, :protocol-impl nil, :max-fixed-arity 1, :protocol-inline nil, :variadic false, :doc "Returns the metadata of obj, returns nil if there is no metadata.", :line 848, :fn-var true, :file nil}, -write {:arglists (quote ([writer s])), :method-params ([{:name writer, :tag nil, :shadow nil} {:name s, :tag nil, :shadow nil}]), :protocol cljs.core/IWriter, :name cljs.core/-write, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 256, :fn-var true, :file nil}, PersistentTreeMapSeq {:line 4844, :file nil, :protocols #{cljs.core/IMeta cljs.core/IEquiv cljs.core/ICollection cljs.core/IHash cljs.core/IEmptyableCollection cljs.core/ICounted cljs.core/ISeqable cljs.core/Object cljs.core/ISequential cljs.core/IWithMeta cljs.core/ISeq}, :num-fields 5, :type true, :name cljs.core/PersistentTreeMapSeq}, hash-iset {:arglists (quote ([s])), :method-params ([{:name s, :tag nil, :shadow nil}]), :name cljs.core/hash-iset, :protocol-impl nil, :max-fixed-arity 1, :private true, :protocol-inline nil, :variadic false, :line 1535, :fn-var true, :file nil}, prim-seq {:arglists (quote ([prim] [prim i])), :method-params ([{:name prim, :tag nil, :shadow nil}] [{:name prim, :tag nil, :shadow nil} {:name i, :tag nil, :shadow nil}]), :name cljs.core/prim-seq, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 623, :fn-var true, :file nil}, -with-meta {:arglists (quote ([o meta])), :method-params ([{:name o, :tag nil, :shadow nil} {:name meta, :tag nil, :shadow nil}]), :protocol cljs.core/IWithMeta, :name cljs.core/-with-meta, :protocol-impl nil, :max-fixed-arity 2, :protocol-inline nil, :variadic false, :line 214, :fn-var true, :file nil}}, :imports nil, :requires-macros {}, :uses-macros nil, :requires {garray goog.array, gobject goog.object, goog.string.format goog.string.format, gstringbuf goog.string.StringBuffer, gstring goog.string}, :uses nil, :excludes #{}, :doc nil, :name cljs.core}, cljs.user {:imports nil, :requires-macros {}, :uses-macros nil, :requires nil, :uses nil, :excludes #{}, :doc nil, :name cljs.user}}
)

(defn reset [] (reset! cljs.analyzer/namespaces nss))
